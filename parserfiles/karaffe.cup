package karaffe.compiler.phase.parser;

import karaffe.compiler.tree.*;
import karaffe.compiler.tree.imports.*;
import karaffe.compiler.tree.compileunits.*;
import java.util.Scanner;
import java.io.StringReader;
import java.io.Reader;
import karaffe.Main;
import java.util.ArrayList;
import java.util.List;

parser code {:

    private final List<ErrorNode> errorList = new ArrayList<>();
    private Lexer lexer;
    private String filePath;

    Parser(Lexer lexer) {
        super(lexer);
        this.lexer = lexer;
    }

    public static void main(String[] args) {
        Reader reader;
        String path;
        if (args.length == 0) {
            path = "Unavailable(Standard Input)";
            System.out.println("Karaffe " + Main.VERSION + " [Standard Input Mode]");
            System.out.println("Type :help for help");
            System.out.print("> ");
            Scanner scanner = new Scanner(System.in);
            StringBuilder source = new StringBuilder();
            while (scanner.hasNextLine()) {
                String next = scanner.nextLine();
                if (next.equals(":exit")) {
                    System.out.println("Bye");
                    break;
                }
                if (isShouldAppend(next)) {
                    source.append(next).append("\n");
                }
                reader = new StringReader(source.toString());
                Parser parser = new Parser(new Lexer(reader));
                parser.setPath(path);
                try {
                    System.out.println("Generated AST:\n" + parser.compileUnit()); //debug
                } catch (Exception e) {
                    e.printStackTrace();
                }
                source.setLength(0); //Clear Text
                System.out.print("> ");
            }
        } else if (args.length == 1) {
            try {
                reader = new java.io.FileReader(args[0]);
                path = args[0];
                Parser parser = new Parser(new Lexer(reader));
                System.out.println(parser.compileUnit());
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            return;
        }
    }

    private static boolean isShouldAppend(String line) {
        switch (line) {
            case ":help":
                System.out.println("");
                System.out.println("Karaffe Compiler HelpPage:\n"
                        + ":exit");
                System.out.println("");
                return false;
            default:
                return true;
        }
    }
    
    public AST compileUnit() throws Exception{
        if( filePath == null ) {
            throw new IllegalStateException("File path is not set.");
        }
        return (AST)this.parse().value;
    }

    public void setPath(String path) {
        this.filePath = path;
    }

    public List<ErrorNode> errors() {
        return errorList;
    }

:}

terminal 
ARROW,
COMMA,
DOT,
IDENTIFIER,
IMPORT,
LBRACE,
RBRACE,
PACKAGE;

non terminal
AliasImport,
AmbiguousName,
BlockImport,
BlockImportBody,
BlockImportBodyList,
CompileUnit,
GroupImport,
Identifier,
IdentifierList,
ImportDecl,
ImportDeclList,
SimpleImport,
PackageDecl;

CompileUnit ::= PackageDecl:p ImportDeclList:i
                    {:RESULT = new CompileUnit(new java.io.File(filePath), p, i);:}
              | error:err
                    {:RESULT = new ErrorNode(lexer.line(),lexer.column(),"CompileUnit", err);:}
              ;

PackageDecl ::= PACKAGE AmbiguousName:name
                    {:RESULT = new PackageDecl(name);:}
              | error:err PACKAGE:p
                    {:
                        ErrorNode node = new ErrorNode(lexer.line(), lexer.column(), "PackageDecl.Before.Package",err,p);
                        errorList.add(node);
                        RESULT = node;
                    :}
              | PACKAGE:p error:err
                    {:
                        ErrorNode node = new ErrorNode(lexer.line(), lexer.column(), "PackageDecl.After.Package",p,err);
                        errorList.add(node);
                        RESULT = node;
                    :}
              | PACKAGE:p IDENTIFIER:id error:err
                    {:
                        ErrorNode node = new ErrorNode(lexer.line(), lexer.column(), "PackageDecl.After.Identifier",p,id,err);
                        errorList.add(node);
                        RESULT = node;
                    :}
              | 
              ;

AmbiguousName ::= AmbiguousName:name DOT Identifier:id
                    {:RESULT = new AmbiguousName(name, id);:}
                | Identifier:id
                    {:RESULT = new AmbiguousName(id);:}
                ;

Identifier ::= IDENTIFIER:id
                    {:
                        RESULT = new Identifier(id);
                    :}
             ;

ImportDeclList ::= ImportDecl:import_ ImportDeclList:importList
                    {:RESULT = new ImportDeclList(import_,importList);:}
                 |
                 ;

ImportDecl ::= SimpleImport:simpleImport
                {:RESULT = new ImportDecl(simpleImport);:}
             | AliasImport:aliasImport
                {:RESULT = new ImportDecl(aliasImport);:}
             | GroupImport:groupImport
                {:RESULT = new ImportDecl(groupImport);:}
             | BlockImport:blockImport
                {:RESULT = new ImportDecl(blockImport);:}
             ;

SimpleImport ::= IMPORT AmbiguousName:name 
                    {:RESULT = new SimpleImport(name);:}
               ;

AliasImport ::= IMPORT AmbiguousName:name ARROW Identifier:id
                    {:RESULT = new AliasImport(name, id);:}
              ;

GroupImport ::= IMPORT AmbiguousName:name DOT LBRACE IdentifierList:idList RBRACE
                    {:RESULT = new GroupImport(name,idList);:}
              ;

IdentifierList ::= Identifier:id
                    {:RESULT = new IdentifierList(id);:}
                 | Identifier:id COMMA IdentifierList:list
                    {:RESULT = new IdentifierList(id,list);:}
                 |
                 ;

BlockImport ::= IMPORT LBRACE BlockImportBodyList:list RBRACE
                    {:RESULT = new BlockImport(list);:}
              ;

BlockImportBodyList ::= BlockImportBody:body BlockImportBodyList:list
                            {:RESULT = new BlockImportBodyList(body,list);:}
                      |
                      ;

BlockImportBody ::= AmbiguousName:name
                        {:RESULT = new SimpleImport(name);:}
                  | AmbiguousName:name ARROW Identifier:id
                        {:RESULT = new AliasImport(name,id);:}
                  | AmbiguousName:name DOT LBRACE IdentifierList:idList RBRACE
                        {:RESULT = new GroupImport(name,idList);:}
                  ;
