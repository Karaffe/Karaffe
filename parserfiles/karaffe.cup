package karaffe.compiler;

import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;

parser code {:
    
    public Parser(Lexer lexer) {
        super(lexer);
    }

    public Program program() throws Exception{
        Program prog = (Program)this.parse().value;
        Context.INSTANCE.beforeGenClassNode();
        return prog;
    }

:}

terminal        ABSTRACT;
terminal        AND;
terminal        ANDC;
terminal        ARROW;
terminal        AT;
terminal        BANG;
terminal        BEQ;
terminal        CLASS;
terminal        COLON;
terminal        COMMA;
terminal        CONST;
terminal        DEF;
terminal        DOT;
terminal        ELSE;
terminal        EQ;
terminal        EQEQ;
terminal        FALSE;
terminal        FINAL;
terminal        GOTO;
terminal        GT;
terminal        GTEQ;
terminal        IF;
terminal        IMPORT;
terminal        LBRACE;
terminal        LBRACKET;
terminal        LPAREN;
terminal        LT;
terminal        LTEQ;
terminal        MAIN;
terminal        MINUS;
terminal        MINUSEQ;
terminal        OR;
terminal        ORC;
terminal        PACKAGE;
terminal        PLUS;
terminal        PLUSEQ;
terminal        PRIVATE;
terminal        PUBLIC;
terminal        RBRACE;
terminal        RBRACKET;
terminal        RPAREN;
terminal        SEMICOLON;
terminal        SLASH;
terminal        STAR;
terminal        STATIC;
terminal        TILARROW;
terminal        TRUE;
terminal        WHILE;
terminal String COMMENT;
terminal String IDENTIFIER;
terminal String INT_LITERAL;
terminal String STRING_LITERAL;

non terminal Annotation                 Annotation;
non terminal Argument                   Arg;
non terminal ClassDef                   ClassDef,InnerClassDef;
non terminal Expression                 Expr,AdditiveExpr,MultiplicativeExpr,MethodInvocation,Primary,UnaryExpr,Literal,IfExpr,WhileExpr,AssignmentExpr, OrExpr, AndExpr, EqExpr, RelExpr, CastExpr;
non terminal FieldDef                   FieldDef, FieldDefInn;
non terminal List<FieldDef>             FieldDefBlockInn;
non terminal FieldDefBlock              FieldDefBlock;
non terminal Identifier                 Ident;
non terminal ImportDef                  ImportDef;
non terminal List<Annotation>           AnnotationList, AnnotationListOpt;
non terminal List<Argument>             ArgList,ArgListOpt;
non terminal List<ClassDef>             ClassDefList,ClassDefListOpt;
non terminal List<Identifier>           IdentList,IdentListComma,TypeArg,TypeArgOpt;
non terminal List<ImportDef>            ImportDefList;
non terminal List<Modifier>             ModifierList, ModifierListOpt;
non terminal List<NodeGeneratable<?>>   MethodBodyList;
non terminal List<Parameter>            ParameterList, ParameterListOpt;
non terminal List<Statement>            ClassBodyList;
non terminal TypeElement                TypeName, TypeNameOpt, UnionType;
non terminal LocalVarDef                LocalVarDef;
non terminal MethodDef                  MethodDef,MainDef;
non terminal Modifier                   Modifier;
non terminal NodeGeneratable            MethodBody, Goto, Label;
non terminal PackageDef                 PackageDef;
non terminal Parameter                  Parameter;
non terminal Program                    CompileUnit;
non terminal Statement                  ClassBody;

precedence left PLUS, MINUS, STAR, SLASH, OR, ORC, AND, ANDC;
precedence left LPAREN;
precedence left DEF,ELSE;
precedence left PUBLIC, PRIVATE, ABSTRACT, STATIC, FINAL;
precedence right BANG;

start with CompileUnit;

CompileUnit ::= PackageDef:p ImportDefList:il ClassDefListOpt:c
                    {:RESULT = new Program(p, il, c);:}
              ;

PackageDef ::= PACKAGE IdentList:l
                {:RESULT = Stmt.packageDef(l, lleft, lright);:}
             |
                {:RESULT = PackageDef.none();:}
             ;

ImportDefList ::= ImportDefList:list ImportDef:d
                    {:list.add(d); RESULT = list;:}
                |
                    {:RESULT = new LinkedList<>();:}
                ;

ClassDefListOpt ::= ClassDefList:c
                    {:RESULT = c;:}
                  | 
                    {:RESULT = new ArrayList<>(0);:}
                  ;


ClassDefList ::= ClassDefList:list ClassDef:c
                    {:list.add(c); RESULT = list;:}
               | ClassDef:c
                    {:RESULT = new LinkedList<>();RESULT.add(c);:}
               ;

ImportDef ::= IMPORT IdentList:il
                {:RESULT = Stmt.importDef(il, illeft, ilright); :}
            ;

ClassDef ::= AnnotationListOpt:a ModifierListOpt:m CLASS Ident:i LBRACE ClassBodyList:l RBRACE
                {:RESULT = Stmt.classDef(a, m, i, l);:}
           ;

AnnotationListOpt ::= AnnotationList:l
                        {:RESULT = l;:}
                    |
                        {:RESULT = new LinkedList<>();:}
                    ;

AnnotationList ::= Annotation:a AnnotationList:list
                    {:RESULT = list; RESULT.add(a);:}
                 | Annotation:a
                    {:RESULT = new LinkedList<>(); RESULT.add(a);:}
                 ;

Annotation ::= AT Ident:id
                {:RESULT = new Annotation(id, idleft, idright);:}
             ;

ModifierListOpt ::= ModifierList:l
                            {:RESULT = l;:}
                       |
                            {:RESULT = new LinkedList<>();:}
                       ;

ModifierList ::= Modifier:m ModifierList:list
                   {:RESULT = list; RESULT.add(m);:}
               | Modifier:m
                   {:RESULT = new LinkedList<>(); RESULT.add(m);:}
               ;

Modifier ::= PUBLIC
               {:RESULT = Modifiers.PUBLIC;:}
           | PRIVATE
               {:RESULT = Modifiers.PRIVATE;:}
           | ABSTRACT
               {:RESULT = Modifiers.ABSTRACT;:}
           | STATIC
               {:RESULT = Modifiers.STATIC;:}
           | FINAL
               {:RESULT = Modifiers.FINAL;:}
           | CONST
               {:RESULT = Modifiers.CONST;:}
           ;

InnerClassDef ::= AnnotationListOpt:a ModifierListOpt:m CLASS Ident:i LBRACE ClassBodyList:l RBRACE
                    {:RESULT = Stmt.innerClassDef(a, m, i, l);:}
                ;

ClassBodyList ::= ClassBodyList:list ClassBody:c
                    {:list.add(c); RESULT = list;:}
                |
                    {:RESULT = new LinkedList<>();:}
                ;

ClassBody ::= FieldDef:f
                {:RESULT = f;:}
            | FieldDefBlock:fb
                {:RESULT = fb;:}
            | InnerClassDef:c
                {:RESULT = c;:}
            | MethodDef:m
                {:RESULT = m;:}
            | MainDef:m
                {:RESULT = m;:}
            ;

FieldDef ::= AnnotationListOpt:a ModifierListOpt:m DEF Ident:id TypeName:type EQ Expr:e
                {:RESULT = Stmt.fieldDef(a, m, id, type, e);:}
           | error:err
                {:Context.INSTANCE.reportSyntaxError(errleft, errright);:}
           ;

FieldDefBlock ::= AnnotationListOpt:a ModifierList:m LBRACE FieldDefBlockInn:l RBRACE
                    {:RESULT = Stmt.fieldDefBlock(a, m, l); :}
                ;

FieldDefBlockInn ::= FieldDefBlockInn:l FieldDefInn:f
                {:l.add(f); RESULT = l;:}
               |
                {:RESULT = new LinkedList<>();:}
               ;

FieldDefInn ::= DEF Ident:id TypeName:type EQ Expr:e
                {:RESULT = Stmt.fieldDef(id, type, e);:}
              | error:err
                {:Context.INSTANCE.reportSyntaxError(errleft, errright);:}
              ;

MethodDef ::= AnnotationListOpt:a ModifierListOpt:m DEF Ident:id LPAREN ParameterListOpt:p RPAREN TypeNameOpt:retType LBRACE MethodBodyList:b RBRACE
                {:RESULT = Stmt.methodDef(a, m, id, p, retType, b);:}
            ;

MainDef ::= MAIN LBRACE MethodBodyList:b RBRACE
                {:RESULT = Stmt.mainDef(b);:}
          ;

ParameterListOpt ::= ParameterList:list
                    {:RESULT = list;:}
                 |
                    {:RESULT = new LinkedList<>();:}
                 ;

ParameterList ::= Parameter:p COMMA ParameterList:list
                    {:RESULT = list; RESULT.add(p);:}
                | Parameter:p
                    {:RESULT = new LinkedList<>();RESULT.add(p);:}
                ;

Parameter ::= Ident:id TypeName:type
                {:RESULT = new Parameter(id, type); :}
            ;

MethodBodyList ::= MethodBodyList:list MethodBody:b
                    {:list.add(b); RESULT = list;:}
                 |
                    {:RESULT = new LinkedList<>();:}
                 ;

MethodBody ::= LocalVarDef:l
                {:RESULT = l;:}
             | Expr:e
                {:RESULT = e;:}
             | Goto:g
                {:RESULT = g;:}
             | Label:l
                {:RESULT = l;:}
             ;

LocalVarDef ::= DEF Ident:id TypeName:type EQ Expr:e
                    {:RESULT = Stmt.localVarDef(id, type, e);:}
              ;

IdentList ::= Ident:id
                {:RESULT = new LinkedList<>(); RESULT.add(id);:}
            | IdentList:list DOT Ident:id
                {:list.add(id); RESULT = list;:}
            ;

Ident ::= IDENTIFIER:id
            {:RESULT = Expr.ident(id, idleft, idright);:}
        ;

Expr ::= IfExpr:e
            {:RESULT = e;:}
       | WhileExpr:e
            {:RESULT = e;:}
       | AssignmentExpr:e
            {:RESULT = e;:}
       ;

AssignmentExpr ::= OrExpr:e
                    {:RESULT = e;:}
                 | Ident:target EQ OrExpr:e
                    {:RESULT = Expr.assignmentExpr(target, e);:}
                 | Ident:target PLUSEQ OrExpr:e
                    {:RESULT = Expr.plusAssignmentExpr(target,e); :}
                 | Ident:target MINUSEQ OrExpr:e
                    {:RESULT = Expr.minusAssignmentExpr(target, e); :}
                 ;

OrExpr ::= AndExpr:e
            {:RESULT = e;:}
         | OrExpr:e1 OR OrExpr:e2
            {:RESULT = Expr.orExpr(e1, e2);:}
         | OrExpr:e1 ORC OrExpr:e2
            {:RESULT = Expr.orExpr(e1, e2);:}
         ;

AndExpr ::= EqExpr:e
            {:RESULT = e;:}
          | AndExpr:e1 AND EqExpr:e2
            {:RESULT = Expr.andExpr(e1, e2);:}
          | AndExpr:e1 ANDC EqExpr:e2
            {:RESULT = Expr.andExpr(e1, e2);:}
          ;

EqExpr ::= RelExpr:e
            {:RESULT = e;:}
         | EqExpr:e1 EQEQ RelExpr:e2
            {:RESULT = Expr.eqeqExpr(e1, e2);:}
         | EqExpr:e1 BEQ RelExpr:e2
            {:RESULT = Expr.beqExpr(e1, e2);:}
         ;

RelExpr ::= AdditiveExpr:e
            {:RESULT = e;:}
          | RelExpr:e1 LT AdditiveExpr:e2
            {:RESULT = Expr.ltExpr(e1, e2);:}
          | RelExpr:e1 GT AdditiveExpr:e2
            {:RESULT = Expr.gtExpr(e1, e2);:}
          | RelExpr:e1 LTEQ AdditiveExpr:e2
            {:RESULT = Expr.lteqExpr(e1, e2);:}
          | RelExpr:e1 GTEQ AdditiveExpr:e2
            {:RESULT = Expr.gteqExpr(e1, e2);:}
          ;

AdditiveExpr ::= MultiplicativeExpr:e 
            {:RESULT = e;:}
        | AdditiveExpr:e1 PLUS MultiplicativeExpr:e2
            {:RESULT = Expr.add(e1, e2, e1left, e1right, e2left, e2right); :}
        | AdditiveExpr:e1 MINUS MultiplicativeExpr:e2
            {:RESULT = Expr.sub(e1, e2, e1left, e1right, e2left, e2right); :}
        ;

MultiplicativeExpr ::= UnaryExpr:e 
            {:RESULT = e;:}
        | MultiplicativeExpr:e1 STAR UnaryExpr:e2
            {:RESULT = Expr.mul(e1, e2, e1left, e1right, e2left, e2right); :}
        | MultiplicativeExpr:e1 SLASH UnaryExpr:e2
            {:RESULT = Expr.div(e1, e2, e1left, e1right, e2left, e2right); :}
        ;

UnaryExpr ::= MINUS UnaryExpr:e
              {:RESULT = Expr.unaryMinus(e);:}
            | BANG UnaryExpr:e
              {:RESULT = Expr.bangExpr(e);:}
            | CastExpr:e
              {:RESULT = e;:}
            | Primary:e
              {:RESULT = e;:}
            ;

CastExpr ::= LPAREN Expr:e RPAREN TILARROW Ident:to
               {:RESULT = Expr.safeCastExpr(e, to); :}
           | LPAREN Expr:e RPAREN ARROW Ident:to
               {:RESULT = Expr.castExpr(e, to);:}
           ;

Primary ::= Literal:l
            {:RESULT = l;:}
          | LPAREN Expr:e RPAREN
            {:RESULT = e;:}
          | Ident:e 
            {:RESULT = e;:}
          | TRUE
            {:RESULT = Expr.trueLiteral();:}
          | FALSE
            {:RESULT = Expr.falseLiteral();:}
          | MethodInvocation:e
            {:RESULT = e;:}
          ;

Literal ::= INT_LITERAL:i
            {:RESULT = Expr.intLiteral(i, ileft, iright);:}
          | STRING_LITERAL:s
            {:RESULT = Expr.stringLiteral(s);:}
          ; 

MethodInvocation ::= Primary:target DOT Ident:id LPAREN ArgListOpt:argList RPAREN
                        {:RESULT = Expr.methodInvocation(target, id, argList);:}
                   | Ident:id LPAREN ArgListOpt:argList RPAREN
                        {:RESULT = Expr.methodInvocation(Expr.ident("this",-1, -1) , id, argList);:}
                   ;

ArgListOpt ::= ArgList:l
                {:RESULT = l;:}
             |
                {:RESULT = new LinkedList<>(); :}
             ;

ArgList ::= Arg:arg COMMA ArgList:list
            {:list.add(arg); RESULT = list;:}
          | Arg:arg
            {:RESULT = new LinkedList<>(); RESULT.add(arg);:}
          ;

Arg ::= Expr:e
            {:RESULT = new Argument(e);:}
      ;

TypeNameOpt ::= TypeName:t
                {:RESULT = t;:}
              |
                {:RESULT = TypeElement.none();:}
              ;


TypeName ::= Ident:id TypeArgOpt:targ
                {:RESULT = Stmt.typeName(id, targ);:}
           ;

TypeArgOpt ::= TypeArg:arg
                {:RESULT = arg;:}
             |
                {:RESULT = new ArrayList<>(0);:}
             ;

TypeArg ::= LBRACKET IdentListComma:arg RBRACKET
            {:RESULT = arg;:}
          ;

IdentListComma ::= Ident:id
                    {:RESULT = new LinkedList<>(); RESULT.add(id);:}
                 | IdentListComma:list COMMA Ident:id
                    {:RESULT = list; RESULT.add(id);:}
                 ;

IfExpr ::= IF Expr:e LBRACE MethodBodyList:b1 RBRACE
            {:RESULT = Expr.ifExpr(e, b1);:}
         | IF Expr:e Expr:b1
            {:RESULT = Expr.ifExpr(e, b1);:}
         | IF Expr:e LBRACE MethodBodyList:b1 RBRACE ELSE LBRACE MethodBodyList:b2 RBRACE
            {:RESULT = Expr.ifExpr(e, b1, b2);:}
         | IF Expr:e Expr:b1 ELSE Expr:b2
            {:RESULT = Expr.ifExpr(e, b1, b2);:}
         ;

WhileExpr ::= WHILE Expr:e Expr:l
                {:RESULT = Expr.whileExpr(e, l);:}
            | WHILE Expr:e LBRACE MethodBodyList:l RBRACE
                {:RESULT = Expr.whileExpr(e, l); :}
            ;

Goto ::= GOTO Label:l
            {:RESULT = Stmt.Goto(l);:}
       ;

Label ::= Ident:i COLON
            {:RESULT = Stmt.label(i);:}
        ;
