package karaffe.compiler;

import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;

parser code {:
    
    public Parser(Lexer lexer) {
        super(lexer);
    }

    public Program program() throws Exception{
        Program prog = (Program)this.parse().value;
        Context.INSTANCE.beforeGenClassNode();
        return prog;
    }

:}

terminal        ABSTRACT;
terminal        AT;
terminal        CLASS;
terminal        COMMA;
terminal        COLON;
terminal        DEF;
terminal        DOT;
terminal        ELSE;
terminal        EQ;
terminal        FALSE;
terminal        FINAL;
terminal        GOTO;
terminal        IF;
terminal        IMPORT;
terminal        LBRACE;
terminal        LBRACKET;
terminal        LPAREN;
terminal        MAIN;
terminal        MINUS;
terminal        PACKAGE;
terminal        PLUS;
terminal        PRIVATE;
terminal        PROTECTED;
terminal        PUBLIC;
terminal        RBRACE;
terminal        RBRACKET;
terminal        RPAREN;
terminal        SEMICOLON;
terminal        SLASH;
terminal        STAR;
terminal        STATIC;
terminal        TRUE;
terminal        WHILE;
terminal String COMMENT;
terminal String IDENTIFIER;
terminal String INT_LITERAL;
terminal String STRING_LITERAL;

non terminal Annotation                 Annotation;
non terminal Argument                   Arg;
non terminal ClassDef                   ClassDef,InnerClassDef;
non terminal Expression                 Expr,Expr1,Expr2,MethodInvocation,Primary,Primary1,Literal,IfExpr,WhileExpr,AssignmentExpr;
non terminal FieldDef                   FieldDef;
non terminal Identifier                 Ident,IdentOpt;
non terminal ImportDef                  ImportDef;
non terminal List<Annotation>           AnnotationList, AnnotationListOpt;
non terminal List<Argument>             ArgList,ArgListOpt;
non terminal List<ClassDef>             ClassDefList,ClassDefListOpt;
non terminal List<Identifier>           IdentList,IdentListComma,TypeArg,TypeArgOpt;
non terminal List<ImportDef>            ImportDefList;
non terminal List<Modifier>             ClassModifierList, ClassModifierListOpt;
non terminal List<NodeGeneratable<?>>   MethodBodyList;
non terminal List<Parameter>            ParameterList, ParameterListOpt;
non terminal List<Statement>            ClassBodyList;
non terminal TypeElement                TypeName,TypeNameOpt;
non terminal LocalVarDef                LocalVarDef;
non terminal MethodDef                  MethodDef,MainDef;
non terminal Modifier                   ClassModifier;
non terminal NodeGeneratable            MethodBody, Goto, Label;
non terminal PackageDef                 PackageDef;
non terminal Parameter                  Parameter;
non terminal Program                    CompileUnit;
non terminal Statement                  ClassBody;

precedence left PLUS, MINUS, STAR, SLASH;
precedence right LPAREN;
precedence left DEF,ELSE;

start with CompileUnit;

CompileUnit ::= PackageDef:p ImportDefList:il ClassDefListOpt:c
                    {:RESULT = new Program(p, il, c);:}
              ;

PackageDef ::= PACKAGE IdentList:l
                {:RESULT = Stmt.packageDef(l, lleft, lright);:}
             |
                {:RESULT = PackageDef.none();:}
             ;

ImportDefList ::= ImportDefList:list ImportDef:d
                    {:list.add(d); RESULT = list;:}
                |
                    {:RESULT = new LinkedList<>();:}
                ;

ClassDefListOpt ::= ClassDefList:c
                    {:RESULT = c;:}
                  | 
                    {:RESULT = new ArrayList<>(0);:}
                  ;


ClassDefList ::= ClassDefList:list ClassDef:c
                    {:list.add(c); RESULT = list;:}
               | ClassDef:c
                    {:RESULT = new LinkedList<>();RESULT.add(c);:}
               ;

ImportDef ::= IMPORT IdentList:il
                {:RESULT = Stmt.importDef(il, illeft, ilright); :}
            ;

ClassDef ::= AnnotationListOpt:a ClassModifierListOpt:m CLASS Ident:i LBRACE ClassBodyList:l RBRACE
                {:RESULT = Stmt.classDef(a, m, i, l);:}
           ;

AnnotationListOpt ::= AnnotationList:l
                        {:RESULT = l;:}
                    |
                        {:RESULT = new LinkedList<>();:}
                    ;

AnnotationList ::= Annotation:a AnnotationList:list
                    {:RESULT = list; RESULT.add(a);:}
                 | Annotation:a
                    {:RESULT = new LinkedList<>(); RESULT.add(a);:}
                 ;

Annotation ::= AT Ident:id
                {:RESULT = new Annotation(id, idleft, idright);:}
             ;

ClassModifierListOpt ::= ClassModifierList:l
                            {:RESULT = l;:}
                       |
                            {:RESULT = new LinkedList<>();:}
                       ;

ClassModifierList ::= ClassModifier:m ClassModifierList:list
                        {:RESULT = list; RESULT.add(m);:}
                    | ClassModifier:m
                        {:RESULT = new LinkedList<>(); RESULT.add(m);:}
                    ;

ClassModifier ::= PUBLIC
                    {:RESULT = Modifiers.PUBLIC;:}
                | PROTECTED
                    {:RESULT = Modifiers.PROTECTED;:}
                | PRIVATE
                    {:RESULT = Modifiers.PRIVATE;:}
                | ABSTRACT
                    {:RESULT = Modifiers.ABSTRACT;:}
                | STATIC
                    {:RESULT = Modifiers.STATIC;:}
                | FINAL
                    {:RESULT = Modifiers.FINAL;:}
                ;

InnerClassDef ::= AnnotationListOpt:a ClassModifierListOpt:m CLASS Ident:i LBRACE ClassBodyList:l RBRACE
                    {:RESULT = Stmt.innerClassDef(a, m, i, l);:}
                ;

ClassBodyList ::= ClassBodyList:list ClassBody:c
                    {:list.add(c); RESULT = list;:}
                |
                    {:RESULT = new LinkedList<>();:}
                ;

ClassBody ::= FieldDef:f
                {:RESULT = f;:}
            | InnerClassDef:c
                {:RESULT = c;:}
            | MethodDef:m
                {:RESULT = m;:}
            | MainDef:m
                {:RESULT = m;:}
            ;

FieldDef ::= AnnotationListOpt:a ClassModifierListOpt:m DEF Ident:id TypeName:type EQ Expr:e
                {:RESULT = Stmt.fieldDef(id, type, e);:}
           ;

MethodDef ::= AnnotationListOpt:a ClassModifierListOpt:m DEF Ident:id LPAREN ParameterListOpt:p RPAREN TypeNameOpt:retType LBRACE MethodBodyList:b RBRACE
                {:RESULT = Stmt.methodDef(a, m, id, p, retType, b);:}
            ;

MainDef ::= MAIN LBRACE MethodBodyList:b RBRACE
                {:RESULT = Stmt.mainDef(b);:}
          ;


IdentOpt ::= Ident:id
                {:RESULT = id;:}
           |
                {:RESULT = Identifier.none();:}
           ;

ParameterListOpt ::= ParameterList:list
                    {:RESULT = list;:}
                 |
                    {:RESULT = new LinkedList<>();:}
                 ;

ParameterList ::= Parameter:p COMMA ParameterList:list
                    {:RESULT = list; RESULT.add(p);:}
                | Parameter:p
                    {:RESULT = new LinkedList<>();RESULT.add(p);:}
                ;

Parameter ::= Ident:id TypeName:type
                {:RESULT = new Parameter(id, type); :}
            ;

MethodBodyList ::= MethodBodyList:list MethodBody:b
                    {:list.add(b); RESULT = list;:}
                 |
                    {:RESULT = new LinkedList<>();:}
                 ;

MethodBody ::= LocalVarDef:l
                {:RESULT = l;:}
             | Expr:e
                {:RESULT = e;:}
             | Goto:g
                {:RESULT = g;:}
             | Label:l
                {:RESULT = l;:}
             ;

LocalVarDef ::= DEF Ident:id TypeName:type EQ Expr:e
                    {:RESULT = Stmt.localVarDef(id, type, e);:}
              ;

IdentList ::= Ident:id
                {:RESULT = new LinkedList<>(); RESULT.add(id);:}
            | IdentList:list DOT Ident:id
                {:list.add(id); RESULT = list;:}
            ;

Ident ::= IDENTIFIER:id
            {:RESULT = Expr.ident(id, idleft, idright);:}
        ;

Expr ::= IfExpr:e
            {:RESULT = e;:}
       | WhileExpr:e
            {:RESULT = e;:}
       | AssignmentExpr:e
            {:RESULT = e;:}
       | Expr1:e
        {:RESULT = e;:}
       ;

AssignmentExpr ::= Ident:target EQ Expr:e
                    {:RESULT = Expr.assignmentExpr(target, e);:}
                 ;

Expr1 ::= Expr1:e1 PLUS Expr2:e2
            {:RESULT = Expr.add(e1, e2, e1left, e1right, e2left, e2right); :}
        | Expr1:e1 MINUS Expr2:e2
            {:RESULT = Expr.sub(e1, e2, e1left, e1right, e2left, e2right); :}
        | Expr2:e
            {:RESULT = e;:}
        ;

Expr2 ::= Expr2:e1 STAR Primary1:e2
            {:RESULT = Expr.mul(e1, e2, e1left, e1right, e2left, e2right); :}
        | Expr2:e1 SLASH Primary1:e2
            {:RESULT = Expr.div(e1, e2, e1left, e1right, e2left, e2right); :}
        | Primary1:e
            {:RESULT = e;:}
        ;

Primary1 ::= Primary:e
            {:RESULT = e;:}
           ;

Primary ::= Literal:l
            {:RESULT = l;:}
          | MINUS Primary:e
            {:RESULT = Expr.unaryMinus(e, eleft, eright);:}
          | LPAREN Expr:e RPAREN
            {:RESULT = e;:}
          | Ident:e 
            {:RESULT = e;:}
          | TRUE
            {:RESULT = Expr.trueLiteral();:}
          | FALSE
            {:RESULT = Expr.falseLiteral();:}
          | MethodInvocation:e
            {:RESULT = e;:}
          ;

Literal ::= INT_LITERAL:i
            {:RESULT = Expr.intLiteral(i, ileft, iright);:}
          | STRING_LITERAL:s
            {:RESULT = Expr.stringLiteral(s);:}
          ; 

MethodInvocation ::= Primary:target DOT Ident:id LPAREN ArgListOpt:argList RPAREN
                        {:RESULT = Expr.methodInvocation(target, id, argList);:}
                   | Ident:id LPAREN ArgListOpt:argList RPAREN
                        {:RESULT = Expr.methodInvocation(Expr.ident("this",-1, -1) , id, argList);:}
                   ;

ArgListOpt ::= ArgList:l
                {:RESULT = l;:}
             |
                {:RESULT = new LinkedList<>(); :}
             ;

ArgList ::= Arg:arg COMMA ArgList:list
            {:list.add(arg); RESULT = list;:}
          | Arg:arg
            {:RESULT = new LinkedList<>(); RESULT.add(arg);:}
          ;

Arg ::= Expr:e
            {:RESULT = new Argument(e);:}
      ;

TypeNameOpt ::= TypeName:t
                {:RESULT = t;:}
              |
                {:RESULT = TypeElement.none();:}
              ;


TypeName ::= Ident:id TypeArgOpt:targ
                {:RESULT = Stmt.typeName(id, targ);:}
           ;

TypeArgOpt ::= TypeArg:arg
                {:RESULT = arg;:}
             |
                {:RESULT = new ArrayList<>(0);:}
             ;

TypeArg ::= LBRACKET IdentListComma:arg RBRACKET
            {:RESULT = arg;:}
          ;

IdentListComma ::= Ident:id
                    {:RESULT = new LinkedList<>(); RESULT.add(id);:}
                 | IdentListComma:list COMMA Ident:id
                    {:RESULT = list; RESULT.add(id);:}
                 ;

IfExpr ::= IF Expr:e LBRACE MethodBodyList:b1 RBRACE
            {:RESULT = Expr.ifExpr(e, b1);:}
         | IF Expr:e Expr:b1
            {:RESULT = Expr.ifExpr(e, b1);:}
         | IF Expr:e LBRACE MethodBodyList:b1 RBRACE ELSE LBRACE MethodBodyList:b2 RBRACE
            {:RESULT = Expr.ifExpr(e, b1, b2);:}
         | IF Expr:e Expr:b1 ELSE Expr:b2
            {:RESULT = Expr.ifExpr(e, b1, b2);:}
         ;

WhileExpr ::= WHILE Expr:e Expr:l
                {:RESULT = Expr.whileExpr(e, l);:}
            | WHILE Expr:e LBRACE MethodBodyList:l RBRACE
                {:RESULT = Expr.whileExpr(e, l); :}
            ;

Goto ::= GOTO Label:l
            {:RESULT = Stmt.Goto(l);:}
       ;

Label ::= Ident:i COLON
            {:RESULT = Stmt.label(i);:}
        ;
