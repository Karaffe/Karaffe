//Karaffe Javacc file

options {
    STATIC = false;
    IGNORE_CASE = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.javacc.ast;

public class KaraffeParser{

    private final Program program = new Program();
    
    public KaraffeParser(String sourceCode){
        this(new java.io.StringReader(sourceCode));
    }


    public int getCurrentTokenBeginColumn(){
        return jj_input_stream.getBeginColumn();
    }

    public int getCurrentTokenEndColumn(){
        return jj_input_stream.getEndColumn();
    }

    public int getCurrentLine(){
        return jj_input_stream.getEndLine();
    }
}


PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestLevel = 0;
}

/*
コメントの処理
*/
SKIP:
{
    " "
    | "\t"
    | < "//" (~["\n"])* <NewLine> >
    | "/*" {
        commentNestLevel++;
        SwitchTo(InComment);
    }
}

<InComment> SKIP:
{
    "/*" {
        commentNestLevel++;
    }
    | <EndOfLine : <NewLine>> 
    | "*/" {
        commentNestLevel--;
        if(commentNestLevel == 0){
            SwitchTo(DEFAULT);
        }
    }
}

/**
    Reserved keywords 
*/
TOKEN:
{
      < Check : "check" >
    | < Public : "public" >
    | < SideEffect : "seffect" >
    | < Switch : "switch" >
    | < To : "to" >
    | < Type : "type" >
    | < Undefined : "undefined" >
}

/**
    Literals
*/
TOKEN:
{
      < BoolLiteral : "true"
                    | "false" >
    | < IntLiteral : <Zero> | (<Minus>)? <NonZero> (<Zero> | <NonZero>)* >
    | < Hexadecimal : (<Minus>)? "0" ["x","X"] (<HexDigit>)+ >
    | < #HexDigit : ["0"-"9" , "A"-"F" , "a"-"f"] > 
    | < FloatLiteral : (<Minus>)? (<Zero> | <IntLiteral>) <Dot> (<Zero> | <NonZero>)+ (<Exp> <IntLiteral> )? >
    | < #Minus : "-" >
    | < #Zero : "0" >
    | < #NonZero : ["1"-"9"] >
    | < #Dot : "." >
    | < #Exp : "e" | "E" >
    | < StringLiteral : "\"" (<StringCharacter>)* "\"" >
    | < #StringCharacter : (~["\"","\\","\n","\r"]) 
                         | <StringEscapeSeq> 
                         | <UnicodeEscape> >
    | < StringEscapeSeq : "\\" ["b","t","n","f","r","\"","\\","\'"] >
    | < UnicodeEscape : "\\u" <HexDigit> <HexDigit> <HexDigit> <HexDigit> >
}

/**
    Identifiers
*/
TOKEN:
{
      < Identifier : <IdentifierHead> (<IdentifierHead> | <IdentifierCharacter>)* >
    | < #IdentifierHead :      [
                                    "\u0041"-"\u005A", //A-Z
                                    "\u0061"-"\u007A"  //a-z
                               ]  >
    | < #IdentifierCharacter : [
                                    "\u0030"-"\u0039", //0-9
                                    "\u0041"-"\u005A", //A-Z
                                    "\u0061"-"\u007A", //a-z
                                    "\u005F" //_
                               ] >
}

/**
    Separators
*/
TOKEN:
{
      < LeftBracket : "[" >
    | < RightBracket : "]" >
    | < Colon : ":" >
    | < EqualSign : "=" >
}

/**
    Other tokens
*/
TOKEN:
{
      < NewLine : "\r"
                | "\n" 
                | "\r\n" >
}


Program parse():
{
    Program p = new Program();
    ASTNode node;
}
{
    (node = programElement() { p.addElement(node); })* <EOF> {
        p.addElement(new EndOfFileStatement());
        return p;
    }
}

ASTNode programElement():
{
    ASTNode node;
}
{
    node = expr() {
        return node;
    }
    | node = statement(){
        return node;
    }
}

Expression expr():
{
    Expression e;
}
{
    e = literals() { return e; }
}

Statement statement():
{
    Statement s;
}
{
    s = variableDeclaration(){
        return s;
    }
}

Expression literals():
{
    Expression l;
}
{
    l = boolLiteral() { return l; }
    | l = intLiteral() { return l; }
    | l = floatLiteral() { return l; }
    | l = stringLiteral() { return l; }
    | l = arrayLiteral() { return l; }
}

Expression boolLiteral():
{
    Token t;
}
{
    t = <BoolLiteral> {
        return new BoolLiteral(Boolean.parseBoolean(t.image));
    }
}

Expression intLiteral():
{
    Token t;
}
{
      t = <IntLiteral> {
        return new IntLiteral(Integer.parseInt(t.image));
    }
    | t = <Hexadecimal> {
        return new IntLiteral(Integer.parseInt(t.image.replaceFirst("0[xX]",""),16));
    }
}

Expression floatLiteral():
{
    Token t;
}
{
    t = <FloatLiteral> {
        return new FloatLiteral(Double.parseDouble(t.image));
    }
}

Expression stringLiteral():
{
    Token t;
}
{
    t = <StringLiteral> {
        return new StringLiteral(t.image);
    }
}

/**
    ArrayLiteral
    ArrayLiteral  = "[" ArrayElements "]"
    ArrayElements = ArrayElement*
    ArrayElement  = expr
*/
Expression arrayLiteral():
{
    ArrayElements elements = ArrayElements.EMPTY;
}
{
    <LeftBracket> (elements = arrayElements())? <RightBracket> {
        return new FixedSizeArrayLiteral(elements,elements.getHeadElementType());
    }
}

/**
    FunctionLiteral
    FunctionLiteral = "[" VariableList "]" "to" FunctionBody
    FunctionBody = Expression
*/
Expression functionLiteral():
{
    VariableList varList = null;
    VariableIdTypePairs varIdPairs = null;
    Expression expr;
}
{
    <LeftBracket> (LOOKAHEAD(2) varList = varList() | varIdPairs = varIdTypePairs())? <RightBracket> <To> expr = expr() {
        if(varList == null && varIdPairs == null){
            return new FunctionLiteral(expr);
        }else if(varList == null && varIdPairs != null){
            return new FunctionLiteral(varIdPairs,expr);
        }else if(varList != null && varIdPairs == null){
            return new FunctionLiteral(varList,expr);
        }
    }
}

VariableList varList():
{
    VariableId var;
    VariableList list = new VariableList();
}
{
    ( (var = variableId()) { list.addVariableElement(var);} )+ {
        return list;
    }
}

VariableIdTypePair varIdTypePair():
{
    VariableId varId;
    TypeId typeId;
}
{
    varId = variableId() <Colon> typeId = typeId() {
        return new VariableIdTypePair(varId,typeId);
    }
}

VariableIdTypePairs varIdTypePairs():
{
    VariableIdTypePair pair;
    VariableIdTypePairs pairs = new VariableIdTypePairs();
}
{
    (pair = varIdTypePair() {pairs.addPair(pair);} )+ {
        return pairs;
    }
}

ArrayElements arrayElements():
{
    ArrayElements elements = new ArrayElements();
    ArrayElement element;
}
{
    (element = arrayElement(){ elements.addElement(element);})+ {
        return elements;
    }
}

ArrayElement arrayElement():
{
    Expression expr;
}
{
    expr = expr() {
        return new ArrayElement(expr);
    }
}

/**
    VariableId
    VariableId = VariableIdHead IdentifierCharacter*
*/
VariableId variableId():
{
    Token t;
}
{
    t = <Identifier> {
        return new VariableId(t.image);
    }
}

/**
    TypeId
    TypeId = TypeIdHead IdentifierCharacter*
*/
TypeId typeId():
{
    Token t;
}
{
    t = <Identifier> { 
        return new TypeId(t.image);
    }
}

Statement variableDeclaration():
{
    VariableId name;
    TypeId typeId = net.nokok.karaffe.javacc.ast.TypeId.UNKNOWN_TYPE;
    ASTNode node;
}
{
    name = variableId() (<Colon> typeId = typeId())? <EqualSign> node = expr(){
        return new VariableDeclaration(name,typeId,node);
    }
}

