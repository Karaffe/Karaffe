
options{
    STATIC = false;
    DEBUG_PARSER = true;
    DEBUG_LOOKAHEAD = true;
    DEBUG_TOKEN_MANAGER = true;
    IGNORE_CASE = false;
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.javacc;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import net.nokok.karaffe.javacc.expr.*;
import net.nokok.karaffe.javacc.identifier.*;
import net.nokok.karaffe.javacc.literal.*;
import net.nokok.karaffe.javacc.stmt.*;
import net.nokok.karaffe.javacc.operator.*;

public class KaraffeParser {
    public final Statements statements = new Statements();
    public static final List codeList = new ArrayList(); //List<String>
   
    public static KaraffeParser createParser(String sourceCode) {
        KaraffeParser parser = new KaraffeParser(new java.io.StringReader(sourceCode));
        codeList.clear();
        codeList.addAll(Arrays.asList(sourceCode.split("\n")));
        return parser;
    }
 
}
PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestCount = 0;
}

SKIP: 
{   
      " " { CompileLog.print("Space");}
    | "\t" { CompileLog.print("Tab");}
    | < "//" (~["\n"])* <NewLine> > { CompileLog.print("//"); }
    | < "/*" > {
         commentNestCount++;
         CompileLog.print("/* : level " + commentNestCount);
         SwitchTo(InComment);
    }
} 

<InComment> SKIP:
{
    "/*" {
        CompileLog.print("/* : level" + commentNestCount);
        commentNestCount++;
    }
    | <NewLine1 : <NewLine> > {CompileLog.print("NewLine in comment");}
    | "*/" {
        CompileLog.print("*/ : level " + commentNestCount);
        commentNestCount--;
        if(commentNestCount == 0){
            CompileLog.print("End Blockcomment");
            SwitchTo(DEFAULT);
        }
    }
}

<InComment> MORE:
{
    <~[]> {CompileLog.print("InComment MORE");}
}

TOKEN:
{
      < Type : "type" > {CompileLog.print("type");}
    | < This : "this" > {CompileLog.print("this");}
    | < SideEffect : "seffect" > {CompileLog.print("seffect");}
    | < Bool : "true" 
             | "false" > {CompileLog.print("Bool");}
    | < Switch : "switch" > {CompileLog.print("switch");}
    | < Check : "check" > {CompileLog.print("check");}
    | < GlobalScope : "global" > {CompileLog.print("global");}
    | < Native : "native" > {CompileLog.print("native");}
    | < Unary : "unary" > {CompileLog.print("unary");}
    | < To : "to" > {CompileLog.print("to");}
    | < Colon : ":" > {CompileLog.print(":");}
    | < Undefined : "undefined" > {CompileLog.print("undefined");}
    | < Void : "Void" > {CompileLog.print("Void");}
    | < IntLiteral : (<SubOp>)? <NonZero> (<Zero> | <NonZero>)* > {CompileLog.print("intLiteral");}
}

TOKEN: 
{
      < Assign : "=" >  {CompileLog.print("=");}
    | < LBracket : "[" > {CompileLog.print("[");}
    | < RBracket : "]" > {CompileLog.print("]");}
    | < Range : ".." > {CompileLog.print("..");}
    | < ClosedRange : ".<" > {CompileLog.print(".<");}
    | < AddOp : "+" > {CompileLog.print("+");}
    | < SubOp : "-" > {CompileLog.print("-");}
    | < MulOp : "*" > {CompileLog.print("*");}
    | < DivOp : "/" > {CompileLog.print("/");}
    | < RemOp : "%" > {CompileLog.print("%");}
    | < Dot : "." > {CompileLog.print(".");}
    | < Exp : "e" | "E" > {CompileLog.print("Exp");}
    
}

TOKEN:
{
      < VariableId : <Lower> (<Alphabet> | <Digit>)* > {CompileLog.print("VariableId");}
    | < Digit : <NonZero> (<Zero>)* > {CompileLog.print("Digit");}
    | < Zero : "0" > {CompileLog.print("0");}
    | < NonZero : ["1"-"9"] > {CompileLog.print("1~9");}
    | < TypeId : <Upper> (<Alphabet>)* > {CompileLog.print("TypeId");}
    | < Alphabet : <Upper> 
                 | <Lower> > {CompileLog.print("A~z");}
    | < Upper : ["A"-"Z"] > {CompileLog.print("A~Z");}
    | < Lower : ["a"-"z"] > {CompileLog.print("a~z");}
    | < NewLine : "\n" 
                | "\r" 
                | "\r\n" > {CompileLog.print("NewLine");}
}
Statements start():
{
Statement s;
}
{
    (s = statement() {statements.addStatement(s);} )* 
    <EOF> {return statements;}
}

Statement statement():
{
Statement t;
}
{
     LOOKAHEAD(2) t = typeAlias() <NewLine> {return t;}
     | LOOKAHEAD(2) t = variableDeclaration() <NewLine> {return t;}
     | <NewLine> {return new NewLineStatement();}
}

/**
TypeAliasの宣言
*/
Statement typeAlias():
{
Token seffect = null;
TypeId newType;
TypeId existingTypeName = net.nokok.karaffe.javacc.identifier.TypeId.Any;
}
{
    (seffect = <SideEffect>)? <Type> newType = typeId() (<Assign> existingTypeName = typeId())? {
        if(seffect == null){
            return new TypeAliasStatement(existingTypeName, newType);
        }else{
            return new MutableTypeAliasStatement(existingTypeName,newType);
        }
    }
}

Expression expr():
{
Expression body;
}
{
    body = literals() {return body;}
}

TypeId typeId():
{
Token token;
}
{
    token = <TypeId> { return new TypeId(token.image);}
}

VariableId variableId():
{
Token token;
}
{
    token = <VariableId> { return new VariableId(token.image);}
}

Expression literals():
{
Expression expr;
}
{
      expr = undefined() {return expr;}
      | expr = boolLiteral() {return expr;}
}

Expression undefined():
{}
{
    <Undefined> { return new UndefinedLiteral();}
}

Expression boolLiteral():
{
Expression expr;
Token token;
}
{
    token = <Bool> {
        return new BoolLiteral(token.image);
    }
}

Statement variableDeclaration():
{
Token seffect = null;
VariableId name;
TypeId type = null;
Expression expr;
}
{
    (seffect = <SideEffect>)? name = variableId() (<Colon> type = typeId())? <Assign> expr = expr() {
        if(type == null){
            type = net.nokok.karaffe.javacc.identifier.TypeId.Inference;
        }
        if(seffect == null){
            return new VariableDeclaration(name,type,expr);
        } else {
            return new MutableVariableDeclaration(name,type,expr);
        }
    }
}
