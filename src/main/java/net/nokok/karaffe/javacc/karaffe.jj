
options{
    STATIC = false;
    IGNORE_CASE = false;
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.javacc;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import net.nokok.karaffe.javacc.expr.*;
import net.nokok.karaffe.javacc.identifier.TypeId;
import net.nokok.karaffe.javacc.identifier.VariableId;
import net.nokok.karaffe.javacc.literal.IntLiteral;
import net.nokok.karaffe.javacc.literal.UndefinedLiteral;
import net.nokok.karaffe.javacc.stmt.*;

public class KaraffeParser {
    public final Statements statements = new Statements();
    public static final List codeList = new ArrayList(); //List<String>
   
    public static KaraffeParser createParser(String sourceCode) {
        KaraffeParser parser = new KaraffeParser(new java.io.StringReader(sourceCode));
        codeList.clear();
        codeList.addAll(Arrays.asList(sourceCode.split("\n")));
        return parser;
    }
 
}
PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestCount = 0;
}

SKIP: 
{   
      " " { CompileLog.print("Space");}
    | "\t" { CompileLog.print("Tab");}
    | < "//" (~["\n"])* <NewLine> > { CompileLog.print("//"); }
    | < "/*" > {
         commentNestCount++;
         CompileLog.print("/* : level " + commentNestCount);
         SwitchTo(InComment);
    }
} 

<InComment> SKIP:
{
    "/*" {
        CompileLog.print("/* : level" + commentNestCount);
        commentNestCount++;
    }
    | <NewLine1 : <NewLine> > {CompileLog.print("NewLine in comment");}
    | "*/" {
        CompileLog.print("*/ : level " + commentNestCount);
        commentNestCount--;
        if(commentNestCount == 0){
            CompileLog.print("End Blockcomment");
            SwitchTo(DEFAULT);
        }
    }
}

<InComment> MORE:
{
    <~[]> {CompileLog.print("InComment MORE");}
}

TOKEN:
{
      < Type : "type" > {CompileLog.print("type");}
    | < This : "this" > {CompileLog.print("this");}
    | < SideEffect : "seffect" > {CompileLog.print("seffect");}
    | < Bool : "true" 
             | "false" > {CompileLog.print("Bool");}
    | < Switch : "switch" > {CompileLog.print("switch");}
    | < Check : "check" > {CompileLog.print("check");}
    | < GlobalScope : "global" > {CompileLog.print("global");}
    | < Native : "native" > {CompileLog.print("native");}
    | < Unary : "unary" > {CompileLog.print("unary");}
    | < To : "to" > {CompileLog.print("to");}
    | < Colon : ":" > {CompileLog.print(":");}
    | < Undefined : "undefined" > {CompileLog.print("undefined");}
    | < Void : "Void" > {CompileLog.print("Void");}
}

TOKEN: 
{
      < Assign : "=" >  {CompileLog.print("=");}
    | < LBracket : "[" > {CompileLog.print("[");}
    | < RBracket : "]" > {CompileLog.print("]");}
    | < Range : ".." > {CompileLog.print("..");}
    | < ClosedRange : ".<" > {CompileLog.print(".<");}
    | < AddOp : "+" > {CompileLog.print("+");}
    | < SubOp : "-" > {CompileLog.print("-");}
    | < MulOp : "*" > {CompileLog.print("*");}
    | < DivOp : "/" > {CompileLog.print("/");}
    | < RemOp : "%" > {CompileLog.print("%");}
    
}

TOKEN:
{
      < VariableId : <Lower> (<Alphabet> | <Digit>)* > {CompileLog.print("VariableId");}
    | < Digit : <NonZero> (<Zero>)* > {CompileLog.print("Digit");}
    | < Zero : "0" > {CompileLog.print("0");}
    | < NonZero : ["1"-"9"] > {CompileLog.print("1~9");}
    | < TypeId : <Upper> (<Alphabet>)* > {CompileLog.print("TypeId");}
    | < Alphabet : <Upper> 
                 | <Lower> > {CompileLog.print("A~z");}
    | < Upper : ["A"-"Z"] > {CompileLog.print("A~Z");}
    | < Lower : ["a"-"z"] > {CompileLog.print("a~z");}
    | < NewLine : "\n" 
                | "\r" 
                | "\r\n" > {CompileLog.print("NewLine");}
}
Statements start():
{Statement s;}
{
    (s = statement() {statements.addStatement(s);} )* 
    <EOF> {return statements;}
}

Statement statement():
{Statement t;}
{
     t = typeAlias() <NewLine> {return t;}
     | <NewLine> {return new NewLineStatement();}
}

/**
TypeAliasの宣言
*/
Statement typeAlias():
{Token newTypeName;Token existingTypeName = null;}
{

    <Type> newTypeName = <TypeId> (<Assign> existingTypeName = <TypeId>)? {
        if(newTypeName.image != "Any" && existingTypeName == null){
            //新しい型がAny型でなく、元の型が省略された場合、Any型として宣言する
            existingTypeName = new Token(KaraffeParserConstants.TypeId,"Any"); 
        }
        TypeAliasStatement statement = new TypeAliasStatement(new Type(existingTypeName.image),new Type(newTypeName.image));
        return statement;
    }
}

Expression body():
{Expression body;}
{
    body = literals() {return body;}
}

TypeId typeId():
{Token token;}
{
    token = <TypeId> { return new TypeId(token.image);}
}

VariableId variableId():
{Token token;}
{
    token = <VariableId> { return new VariableId(token.image);}
}

Expression literals():
{Expression expr;}
{
      expr = undefined() {return expr;}
    | expr = intLiteral() {return expr;}
}

Expression undefined():
{}
{
    <Undefined> { return new UndefinedLiteral();}
}

Expression intLiteral():
{Token a;Token b;List tokenList = new ArrayList();}
{
    a = <NonZero> (b = <Digit> {tokenList.add(b);}) {
        if(tokenList.isEmpty()){
            return new IntLiteral(Integer.parseInt(a.image));
        }
        StringBuilder sb = new StringBuilder();
        sb.append(a.image);
        for(Object obj : tokenList){
            Token t = (Token)obj;
            sb.append(t.image);
        }
        return new IntLiteral(Integer.parseInt(sb.toString()));
    }
    | a = <Zero> {
        return new IntLiteral(Integer.parseInt(a.image));
    }
}
