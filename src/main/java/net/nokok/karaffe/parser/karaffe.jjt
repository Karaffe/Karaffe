options {
    STATIC = false;
    IGNORE_CASE = false;
    UNICODE_INPUT = true;
    MULTI = true;
    VISITOR = true;
    VISITOR_EXCEPTION = "net.nokok.karaffe.parser.excptn.KaraffeParserException";
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.parser;

import net.nokok.karaffe.parser.util.*;
import java.util.*;

public class KaraffeParser{

    public KaraffeParser(String sourceCode){
        this(new java.io.StringReader(sourceCode));
    }

    public int getCurrentTokenBeginColumn(){
        return jj_input_stream.getBeginColumn();
    }

    public int getCurrentTokenEndColumn(){
        return jj_input_stream.getEndColumn();
    }

    public int getCurrentLine(){
        return jj_input_stream.getEndLine();
    }
}


PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestLevel = 0;
}

//文法定義

/**

    型宣言

           type 識別子
    修飾子 type 識別子
    修飾子 type 識別子 : 継承元型名
    修飾子 type 識別子              <- 実装インターフェース
    修飾子 type 識別子 : 継承元型名 <- 実装インターフェース
    修飾子 type 識別子 : 継承元型名[型パラメータ]
    修飾子 type 識別子                            <- 実装インターフェース[型パラメータ]
    修飾子 type 識別子 : 継承元型名[型パラメータ] <- 実装インターフェース[型パラメータ]
 */
void TypeDeclaration():
{}
{
    //修飾子            type   識別子        :        継承元型名     <-             実装インターフェース
    (ModifierOfType())? <Type> TypeElement() (<Colon> SuperType())? (<ReverseArrow> Interfaces())? 
}

void SuperType():
{}
{
    TypeElement()
}

void Interfaces():
{}
{
    (LOOKAHEAD(2) TypeElement())+
}

/**
    インターフェース宣言
    interface 識別子               <- 拡張インターフェース
    interface 識別子[型パラメータ] <- 拡張インターフェース[型パラメータ]
 */
void InterfaceDeclaration():
{}
{
    //interface 識別子        <-             拡張インターフェース
    <Interface> TypeElement() (<ReverseArrow> Interfaces())?
}

/**
    TypeAlias宣言
    修飾子 typealias 識別子 : 識別子

    ↓未実装
    修飾子 typealias 識別子 : 識別子[型パラメータ]
 */
void TypeAliasDeclaration():
{}
{
    //修飾子            typealias   識別子        :       識別子
    (ModifierOfType())* <TypeAlias> TypeElement() <Colon> TypeElement()
}

/**
    変数または関数の宣言

    変数宣言
           識別子 : 型名
    修飾子 識別子        = 式
    修飾子 識別子 : 型名
    修飾子 識別子 : 型名 = 式
    修飾子 識別子 : 型名[型パラメータ] = 式
    
    関数宣言
    修飾子 識別子                      = 関数リテラル
    修飾子 識別子 : 型名リスト -> 型名
    修飾子 識別子 : 型名リスト -> 型名 = 関数リテラル

    修飾子 識別子[型パラメータ] : 型名リスト[型パラメータ] -> 型名[型パラメータ]
    修飾子 識別子[型パラメータ] : 型名リスト[型パラメータ] -> 型名[型パラメータ] = 関数リテラル
*/
void VariableOrFunctionDeclaration():
{}
{
    (Modifier())* Identifier() (LOOKAHEAD(3) (<Colon> VariableOrFunctionTypeDeclaration() <EqualSign> Expression())|
                                             (<Colon> VariableOrFunctionTypeDeclaration() | <EqualSign> Expression()))
}

/**
    Enumの宣言

    enum 識別子: [識別子 識別子...]
 */
void EnumDeclaration():
{}
{
    <Enum> Identifier() <Colon> <LeftBracket> EnumElements() <RightBracket>
}

void EnumElements():
{}
{
    (Identifier())+
}

/**
    型宣言部
    
    Tは型または型[型パラメータ]

    T
    T -> T
    T -> T ... -> T
    T T ...    -> T
    T -> T T -> T
 */
void VariableOrFunctionTypeDeclaration() #void:
{}
{
    TypeElement() (LOOKAHEAD(2)(SingleArrow())? TypeElement())*
}

/**
    型
    または
    型[型パラメータ]
 */
void TypeElement() #void:
{}
{
    KaraffeIdentifier() (LOOKAHEAD(2)TypeParameters())?
  | TupleLiteral()
}

/**
    関数リテラル

    () -> ...
    () -> { ... }
    (引数) -> ...
    (引数:型) -> ...
    (引数1 引数2...) -> ...
    (引数1:型 引数2:型 ...) -> ...
 */
void FunctionLiteral():
{}
{
    //(         引数:型                       )            ->            {            ...          }             ...
    <LeftParen> (LOOKAHEAD(2) TypeElement())* <RightParen> SingleArrow() (<LeftBrace> Expression() <RightBrace> | Expression())
}

/**
    Import文

    import 識別子
    import 識別子 -> 別名
    import 識別子 { }

 */
void ImportStatement():
{}
{
    <Import> (LOOKAHEAD(2)Identifier() (<SingleArrow> Identifier())?)* (<LeftBrace> Statements() <RightBrace>)?
}

/**
    型パラメータ
    [型パラメータリスト]

    型パラメータリスト
    型パラメータ 型パラメータ ...

    型パラメータ
    
 */
void TypeParameters():
{}
{
    <LeftBracket> (TypeParameter())+ <RightBracket> 
}

/**
    型パラメータ

    識別子
    識別子 境界型
 */
void TypeParameter():
{}
{
    TypeElement() (LOOKAHEAD(2)TypeBound())?
}

/**
    境界型

    < 型変数
    < インターフェース & インターフェース ...
    < 型パラメータ
 */
void TypeBound():
{}
{
    <Lt> TypeElement() (LOOKAHEAD(2)<And> TypeElement())*
}

/**
    module モジュール名
 */
void ModuleDeclarationStatement():
{}
{
    <Module> Identifier()
}

/**
    アノテーション

    @識別子
 */
void Annotation():
{}
{
    <Atmark> Identifier()
}

/*
コメントの処理
*/
SKIP:
{
    " "
    | "\t"
    | < "//" (~["\n"])* <NewLine> >
    | "/*" {
        commentNestLevel++;
        SwitchTo(InComment);
    }
}

<InComment> SKIP:
{
    "/*" {
        commentNestLevel++;
    }
    | < ~[]>
    | <EndOfLine : <NewLine>> 
    | "*/" {
        commentNestLevel--;
        if(commentNestLevel == 0){
            SwitchTo(DEFAULT);
        }
    }
}

/**
    Reserved keywords 
*/
TOKEN:
{
    < Abstract : "abstract" >
    | < Check : "check" >
    | < Enum : "enum" >
    | < Import : "import" >
    | < Interface : "interface" >
    | < Lazy : "lazy" >
    | < Module : "module" >
    | < Operator : "op" >
    | < Override : "override" >
    | < Private : "private" >
    | < Sealed : "sealed" >
    | < Switch : "switch" >
    | < Type : "type" >
    | < UnaryOperator : "unaryop" >
    | < TypeAlias : "typealias" >
    | < Undefined : "undefined" >
    | < Variable : "var" >
}

/**
    Literals
*/
TOKEN:
{
      < BoolLiteral : "true"
                    | "false" >
    | < IntLiteral : <Zero> | (<Minus>)? <NonZero> (<Zero> | <NonZero>)* >
    | < Hexadecimal : (<Minus>)? "0" ["x","X"] (<HexDigit>)+ >
    | < #HexDigit : ["0"-"9" , "A"-"F" , "a"-"f"] > 
    | < FloatLiteral : (<Minus>)? (<Zero> | <IntLiteral>) <Dot> (<Zero> | <NonZero>)+ (<Exp> <IntLiteral> )? >
    | < #Zero : "0" >
    | < #NonZero : ["1"-"9"] >
    | < #Exp : "e" | "E" >
    | < StringLiteral : "\"" (<StringCharacter>)* "\"" >
    | < #StringCharacter : (~["\"","\\","\n","\r"]) 
                         | <StringEscapeSeq> 
                         | <UnicodeEscape> >
    | < StringEscapeSeq : "\\" ["b","t","n","f","r","\"","\\","\'"] >
    | < UnicodeEscape : "\\u" <HexDigit> <HexDigit> <HexDigit> <HexDigit> >
}

void Literal() #void:
{}
{
    FunctionLiteral()
    | BoolLiteral()
    | IntLiteral()
    | FloatLiteral()
    | StringLiteral()
    | UndefinedLiteral()
}

/**
    Identifiers
*/
TOKEN:
{
      < Identifier : <IdentifierHead> (<IdentifierChar>)* >
    | < #IdentifierHead : [
                                    "A"-"Z", 
                                    "a"-"z", 
                                    "_",     
                                    "ぁ"-"ゖ",
                                    "ァ"-"ヺ",
                                    "\u4E00"-"\u9FFF"  //漢字     CJK Unified Ideographs
    ] >
    | < #IdentifierChar :      [
                                    "'",     
                                    "0"-"9",
                                    "A"-"Z", 
                                    "a"-"z", 
                                    "_",     
                                    "ぁ"-"ゖ",
                                    "ァ"-"ヺ",
                                    "\u4E00"-"\u9FFF"  //漢字     CJK Unified Ideographs
                               ]  >
    | < JavaFQCN : <Identifier> (<Dot> <Identifier>)* >
}

Token Identifier() #void:
{
    Token t;
}
{
    t = KaraffeIdentifier(){
        return t;
    }
    | t = JavaFQCN() {
        return t;
    }
}

Token KaraffeIdentifier():
{
    Token t;
}
{
    t = <Identifier> {
        jjtThis.jjtSetValue(t);
        return t;
    }
}

Token JavaFQCN():
{
    Token t;
}
{
    t = <JavaFQCN> {
        jjtThis.jjtSetValue(t);
        return t;
    }
}

ASTCompileUnit CompileUnit():
{}
{
    (LOOKAHEAD(3) Statement() | LOOKAHEAD(3) MethodInvocation() | NewLineToken())* <EOF> {
        return jjtThis;
    }
}

void Statements() #void:
{}
{
    (LOOKAHEAD(2) Statement())*
}

void Statement() #void:
{}
{
    LOOKAHEAD(2) Declaration()
    | ImportStatement()
}

void Declaration() #void:
{}
{
    LOOKAHEAD(3) VariableOrFunctionDeclaration()
    | LOOKAHEAD(3) TypeDeclaration()
    | InterfaceDeclaration()
    | TypeAliasDeclaration()
    | ModuleDeclarationStatement()
    | EnumDeclaration()
}

//MethodInvocations

void MethodInvocation():
{}
{
    MethodOrExprName() Arguments() (LOOKAHEAD(2) (<Dot>)? (LOOKAHEAD(2) MethodOrExprName())? Arguments())*
}

void MethodOrExprName():
{}
{
    Identifier()
}

void Arguments() #void:
{}
{
    LOOKAHEAD(3) <LeftParen> <RightParen>
  | (LOOKAHEAD(3) <LeftParen>)? ArgumentList() (LOOKAHEAD(2) <RightParen>)?
}

void ArgumentList():
{}
{
    Expression() (LOOKAHEAD(2) Expression())*
}

/**
    ModuleName::ElementName...
 */
void ExplicitModuleElementAccess():
{}
{
    Identifier() (<DoubleColon> Identifier())+
}

void Expression():
{}
{
    LOOKAHEAD(2) OrExpr()
    | LOOKAHEAD(2) AssignmentExpression()
}

void AssignmentExpression():
{}
{
    LOOKAHEAD(2) OrExpr()
    | LOOKAHEAD(2) Assignment()
}

void Assignment():
{}
{
    LeftHandSide() AssignmentOperator() Expression()
}

void LeftHandSide():
{}
{
    LOOKAHEAD(2) Identifier()
  | LOOKAHEAD(2) ExplicitModuleElementAccess() (MethodInvocation())?
}

void AssignmentOperator() #void:
{}
{
    Assign() | AA() | SA() | MA() | DA() | RA()
}

void OrExpr()#void:
{}
{
    (AndExpr() (LOOKAHEAD(2) Or() AndExpr())*) #ExprNode(>1)
}

void AndExpr()#void:
{}
{
    (Equality() (LOOKAHEAD(2) And() Equality())*) #ExprNode(>1)
}

void Equality()#void:
{}
{
    (Relational() (LOOKAHEAD(2) (EqualTo()|
                                NotEqualTo()) Relational())*) #ExprNode(>1)
}

void Relational()#void:
{}
{
    (Range() (LOOKAHEAD(2) (LessThan() |
                 GreaterThan()|
                 LessThanEqualTo() |
                 GreaterThanEqualTo()) Range())*) #ExprNode(>1)
}

void Range()#void:
{}
{
    (Additive() (LOOKAHEAD(2) ( ClosedRange() | 
                              HalfOpenRange()) Additive())*) #ExprNode(>1)
}

void Additive() #void:
{}
{
    (Multiplicative() (LOOKAHEAD(2) (Plus() | 
                                    Minus()) Multiplicative())*) #ExprNode(>1)
}

void Multiplicative() #void:
{}
{
    (UnaryExpr() (LOOKAHEAD(2) (Star()|
                               Slash()|
                               SafeDiv()|
                               SafeRem()|
                               Percent()|
                               Hat()) UnaryExpr())* ) #ExprNode(>1)
}

void UnaryExpr() #void:
{}
{
   UnaryPlus()  UnaryExprNotPlusMinus() 
  | UnaryMinus() UnaryExprNotPlusMinus()
  | UnaryExprNotPlusMinus()
}

void UnaryExprNotPlusMinus() #void:
{}
{
      LOOKAHEAD(3) Primary()
    | UnaryBang() Primary()
}

void Primary() #void:
{}
{
      LOOKAHEAD(2) Literal()
    | LOOKAHEAD(2) Identifier()
    | LOOKAHEAD(2) <LeftParen> Expression() <RightParen>
    | LOOKAHEAD(2) MethodInvocation()
}

/**
    Identifier=>Identifier...
 */
void ElementAccess():
{}
{
    Identifier()( <DoubleArrow> Identifier())+
}

void Modifier() #void:
{}
{
    LOOKAHEAD(3) ModifierOfType()
    | LOOKAHEAD(3) ModifierOfVariable()
    | LOOKAHEAD(2) ModifierOfFunction()
    | ModifierOfOperator()
}

void ModifierOfType():
{}
{
    (PrivateModifier())? AbstractOrSealed()
}

void AbstractOrSealed() #void:
{}
{
    (AbstractModifier() | SealedModifier())?
}

void ModifierOfVariable():
{}
{
    (PrivateModifier())? (VariableModifier())? (LazyModifier())?
}

void ModifierOfFunction():
{}
{
    PrivateOrOverride() AbstractOrSealed() (VariableModifier())?
}

void PrivateOrOverride() #void:
{}
{
    (PrivateModifier() | OverrideModifier())?
}

void ModifierOfOperator():
{}
{
    UnaryOpModifier() | OpModifier()
}


/**
    Delimiters
*/
TOKEN:
{
      < LeftBracket : "[" >
    | < RightBracket : "]" >
    | < LeftBrace : "{" >
    | < RightBrace : "}" >
    | < LeftParen : "(" >
    | < RightParen : ")" >
    | < Colon : ":" >
    | < DoubleColon : "::">
    | < Dot : "." >
}

/**
    Operators
 */
TOKEN:
{

    < EqualSign : "=" >
    | < AA : "+=" >
    | < SA : "-=" >
    | < MA : "*=" >
    | < DA : "/=" >
    | < RA : "%=" >
    | < Lt : "<" >
    | < LtE : "<=" >
    | < Gt : ">" >
    | < GtE : ">=" >
    | < Plus : "+" >
    | < Minus : "-" >
    | < Star : "*" >
    | < Slash : "/" >
    | < SafeDiv : "/?" >
    | < Percent : "%" >
    | < SafeRem : "%?" >
    | < Tilde : "~" >
    | < Bang : "!" >
    | < And : "&" > 
    | < Or : "|" >
    | < Hat : "^" >
    | < Question : "?" >
    | < ReverseArrow : "<-" >
    | < ReverseArrowChar : "←" >
    | < SingleArrowChar : "→" >
    | < SingleArrow : "->" >
    | < CastArrow : "~>" >
    | < TypeCheckArrow : "~>?" >
    | < DoubleArrow : "=>" >
    | < EqualTo : "==" >
    | < NotEqualTo : "!=" >
    | < NonComparable : "!<>=" >
    | < Comparable : "<>=" >
    | < ClosedRange : ".." >
    | < HalfOpenRange : ".<" >

}

/**
    Other tokens
*/
TOKEN:
{
      < NewLine : "\r"
                | "\n" 
                | "\r\n" >
      | < Atmark : "@" >
}


void AbstractModifier():
{
    Token t;
}
{
    t = <Abstract> {
        jjtThis.jjtSetValue(t);
    }
}

void OverrideModifier():
{
    Token t;    
}
{
    t = <Override> {
        jjtThis.jjtSetValue(t);
    }
}

void PrivateModifier():
{
    Token t;
}
{
    t = <Private> {
        jjtThis.jjtSetValue(t);
    }
}

void SealedModifier():
{
    Token t;
}
{
    t = <Sealed> {
        jjtThis.jjtSetValue(t);
    }
}

void LazyModifier():
{
    Token t;
}
{
    t = <Lazy> {
        jjtThis.jjtSetValue(t);
    }
}

void OpModifier():
{
    Token t;
}
{
    t = <Operator> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryOpModifier():
{
    Token t;
}
{
    t = <UnaryOperator> {
        jjtThis.jjtSetValue(t);
    }
}

void VariableModifier():
{
    Token t;
}
{
    t = <Variable> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryPlus():
{
    Token t;
}
{
    t = <Plus> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryBang():
{
    Token t;
}
{
    t = <Bang> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryMinus():
{
    Token t;
}
{
    t = <Minus> {
        jjtThis.jjtSetValue(t);
    }
}

void NewLineToken():
{}
{
    <NewLine>
}

void Star():
{
    Token t;
}
{
    t = <Star> {
        jjtThis.jjtSetValue(t);
    }
}

void Slash():
{
    Token t;
}
{
    t = <Slash> {
        jjtThis.jjtSetValue(t);
    }
}

void Percent():
{
    Token t;
}
{
    t = <Percent> {
        jjtThis.jjtSetValue(t);
    }
}

void SafeDiv():
{
    Token t;
}
{
    t = <SafeDiv> {
        jjtThis.jjtSetValue(t);
    }
}

void SafeRem():
{
    Token t;
}
{
    t = <SafeRem> {
        jjtThis.jjtSetValue(t);
    }
}

void Hat():
{
    Token t;
}
{
    t = <Hat> {
        jjtThis.jjtSetValue(t);
    }
}

void Plus():
{
    Token t;
}
{
    t = <Plus> {
        jjtThis.jjtSetValue(t);
    }
}

void Minus():
{
    Token t;
}
{
    t = <Minus> {
        jjtThis.jjtSetValue(t);
    }
}

void EqualTo():
{
    Token t;
}
{
    t = <EqualTo> {
        jjtThis.jjtSetValue(t);
    }
}

void NotEqualTo():
{
    Token t;
}
{
    t = <NotEqualTo> {
        jjtThis.jjtSetValue(t);
    }
}

void GreaterThan():
{
    Token t;
}
{
    t = <Gt> {
        jjtThis.jjtSetValue(t);
    }
}

void LessThan():
{
    Token t;
}
{
    t = <Lt> {
        jjtThis.jjtSetValue(t);
    }
}

void GreaterThanEqualTo():
{
    Token t;
}
{
    t = <GtE> {
        jjtThis.jjtSetValue(t);
    }
}

void LessThanEqualTo():
{
    Token t;
}
{
    t = <LtE> {
        jjtThis.jjtSetValue(t);
    }
}

void Comparable():
{
    Token t;
}
{
    t = <Comparable> {
        jjtThis.jjtSetValue(t);
    }
}

void NonComparable():
{
    Token t;
}
{
    t = <NonComparable> {
        jjtThis.jjtSetValue(t);
    }
}

void And():
{
    Token t;
}
{
    t = <And> {
        jjtThis.jjtSetValue(t);
    }
}
void Or():
{
    Token t;
}
{
    t = <Or> {
        jjtThis.jjtSetValue(t);
    }
}


void BoolLiteral():
{
    Token t;
}
{
    t = <BoolLiteral> {
        jjtThis.jjtSetValue(t);
    }
}


void IntLiteral():
{
    Token t;
}
{
    t = <IntLiteral> {
        jjtThis.jjtSetValue(t);
    }
    | t = <Hexadecimal> {
        jjtThis.jjtSetValue(t);
    }
}

void FloatLiteral():
{
    Token t;
}
{
    t = <FloatLiteral> {
        jjtThis.jjtSetValue(t);
    }
}

void StringLiteral():
{
    Token t;
}
{
    t = <StringLiteral> {
        jjtThis.jjtSetValue(t);
    }
}

void TupleLiteral():
{
    Token t;
}
{
    t = "#" <LeftParen> (LOOKAHEAD(2) Identifier() | LOOKAHEAD(2) Expression())* <RightParen>
}

void UndefinedLiteral():
{
    Token t;
}
{
    t = <Undefined> {
        jjtThis.jjtSetValue(t);
    }
}

void SingleArrow():
{
    Token t;
}
{
    t = <SingleArrow> | t = <SingleArrowChar> {
        jjtThis.jjtSetValue(t);
    }
}
void Assign():
{
    Token t;
}
{
    t = <EqualSign> {
        jjtThis.jjtSetValue(t);
    }
}

void ClosedRange():
{
    Token t;
}
{
    t = <ClosedRange> {
        jjtThis.jjtSetValue(t);
    }
}

void HalfOpenRange():
{
    Token t;
}
{
    t = <HalfOpenRange> {
        jjtThis.jjtSetValue(t);
    }
}

void AA():
{
    Token t;
}
{
    t = <AA> {
        jjtThis.jjtSetValue(t);
    }
}

void SA():
{
    Token t;
}
{
    t = <SA> {
        jjtThis.jjtSetValue(t);
    }
}

void MA():
{
    Token t;
}
{
    t = <MA> {
        jjtThis.jjtSetValue(t);
    }
}

void DA():
{
    Token t;
}
{
    t = <DA> {
        jjtThis.jjtSetValue(t);
    }
}

void RA():
{
    Token t;
}
{
    t = <RA> {
        jjtThis.jjtSetValue(t);
    }
}

