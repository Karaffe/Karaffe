options {
    STATIC = false;
    IGNORE_CASE = false;
    UNICODE_INPUT = true;
    MULTI = true;
    VISITOR = true;
    VISITOR_EXCEPTION = "net.nokok.karaffe.parser.excptn.KaraffeParserException";
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.parser;

import net.nokok.karaffe.parser.util.*;
import java.util.*;

public class KaraffeParser{

    public KaraffeParser(String sourceCode){
        this(new java.io.StringReader(sourceCode));
    }

    public int getCurrentTokenBeginColumn(){
        return jj_input_stream.getBeginColumn();
    }

    public int getCurrentTokenEndColumn(){
        return jj_input_stream.getEndColumn();
    }

    public int getCurrentLine(){
        return jj_input_stream.getEndLine();
    }
}


PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestLevel = 0;
}

void TypeDeclaration():
{}
{
    (Documentation())? (TypeModifier())? <Type> TypeElement() (<Colon> SuperType())? (<ReverseArrow> Interfaces())?
    (LOOKAHEAD(TypeDeclBody()) TypeDeclBody())?
}

void TypeModifier():
{}
{
    AbstractModifier() | 
    SealedModifier()
}

void TypeDeclBody():
{}
{
    TypeDeclBody1() (LOOKAHEAD( TypeDeclBody1())  TypeDeclBody1())*
}

void TypeDeclBody1() #void:
{}
{
    (LOOKAHEAD(VariableOrFunctionDeclaration()) VariableOrFunctionDeclaration() | 
    LOOKAHEAD(Assignment()) Assignment() |
    LOOKAHEAD(MethodInvocation()) MethodInvocation() )
}

void AlgebraicDataTypeDecl():
{}
{
    (Documentation())? <Case> <Type> TypeElement() <EqualSign> AlgebraicDataTypeDeclBody() (<Or> AlgebraicDataTypeDeclBody())+
}

void AlgebraicDataTypeDeclBody():
{}
{
    Constructor() (LOOKAHEAD(ExistingTypeOrTParameter()) ExistingTypeOrTParameter())*
}

void Constructor():
{}
{
    TypeElement()
}

void ExistingTypeOrTParameter():
{}
{
    LOOKAHEAD(2) TypeElement() |
    LOOKAHEAD(2) TypeElementBinding() | 
    LOOKAHEAD(2) VarIdentifier()
}

void InterfaceDeclaration():
{}
{
    (Documentation())? <Interface> TypeElement() (<ReverseArrow> Interfaces())? 
}

void TypeAliasDeclaration():
{}
{
    (Documentation())? <TypeAlias> TypeElement() <Colon> TypeElement() 
}

void FuncAliasDeclaration():
{}
{
    (Documentation())? <FuncAlias> FuncAliasAfter() <Colon> FuncAliasBefore()
}

void FuncAliasAfter():
{}
{
    VarIdentifier() <LeftParen> (TypeElementBinding())* <RightParen>
}

void FuncAliasBefore():
{}
{
    Identifier() (<Dot> Identifier())* <LeftParen> (VarIdentifier())* <RightParen>
}

void VariableOrFunctionDeclaration():
{}
{
    (Documentation())? VarOrFuncModifier() "def" VarIdentifier() (<Colon> ValueType())? (LOOKAHEAD(((FunctionDeclBody()) | (<EqualSign> Body()))) ((FunctionDeclBody()) | (<EqualSign> Body())))?
}

void VarOrFuncModifier():
{}
{
    (OverrideModifier() | LazyModifier() | VariableModifier())*
}

void FunctionDeclBody():
{}
{
     FuncDeclBody1() (LOOKAHEAD(FuncDeclBody1()) FuncDeclBody1())*
}

void FuncDeclBody1() #void:
{}
{
    LOOKAHEAD(FuncPattern()) FuncPattern() |
    Statement() |
    LOOKAHEAD(Expression()) Expression()
}

void ValueType():
{}
{
    (LOOKAHEAD((TypeElementBinding() | TypeElement())) (LOOKAHEAD(2) TypeElementBinding() |LOOKAHEAD(2) TypeElement()))+ (<Star> #VarArgs(true))? (<SingleArrow> ReturnType())?
}

void Body():
{}
{
    Expression()
}

void FuncPattern():
{}
{
    MethodName() ArgVariables() (<Atmark> Guard())? <DoubleArrow> PatternBody()
}

void PatternBody():
{}
{
    Expression() (<SemiColon>)?
}

void ArgVariables():
{}
{
    (ArgVariable() (ColonType())?)*
}

void ArgVariable():
{}
{
    LOOKAHEAD(2) WildCard() |
    LOOKAHEAD(2) VarIdentifier() |
    LOOKAHEAD(2) Literal()
}

void Guard():
{}
{
    Expression()
}

void EnumDeclaration():
{}
{
    (Documentation())? <Enum> TypeIdentifier() <Colon> <LeftBracket> EnumElements() <RightBracket> 
}

void EnumElements():
{}
{
    (TypeIdentifier())+
}

void TypeElement():
{}
{
    JavaType() | 
    TypeWithTypeParams() |
    LOOKAHEAD(2) FunctionType() |
    LOOKAHEAD(2) (<LeftParen> <RightParen>) #UnitType(true)
}

void TypeElementBinding():
{}
{
    VarIdentifier() <Colon> TypeElement()
}

void ExpressionBinding():
{}
{
    Expression() <Colon> TypeElement()
}

void JavaType():
{}
{
    (LOOKAHEAD(VarIdentifier() <Dot>) VarIdentifier() <Dot>)+ TypeElement()
}

void TypeWithTypeParams() #void:
{}
{
    TypeIdentifier() (LOOKAHEAD(2) TypeParameters())?
}

void FunctionType():
{}
{
    <LeftParen> (TypeElement())+ <SingleArrow> ReturnType() <RightParen>
}

void FunctionLiteral():
{}
{
    FunctionLiteralParameters() <SingleArrow> ((<LeftBrace> Expression() <RightBrace>)| Expression())
}

void FunctionLiteralParameters():
{}
{
    VarIdentifier() |
    <LeftParen> (LOOKAHEAD(2) TypeElementBinding() | LOOKAHEAD(2) VarIdentifier() )* <RightParen>
}

void ImportStatement():
{}
{
    <Import> (LOOKAHEAD(2) ((TypeIdentifier()|JavaFQCN())) (<SingleArrow> Alias())?)+
}

void Alias():
{}
{
    TypeIdentifier()
}

void JavaFQCN():
{}
{
    StringLiteral()
}

void ExtendsType():
{}
{
    (Documentation())? "extends" TypeElement() <AA> VarIdentifier()
}

void TypeParameters():
{}
{
    <LeftBracket> (TypeParameter())+ <RightBracket> 
}

void TypeParameter():
{}
{
    LOOKAHEAD(2) TypeElement() (TypeBound())? |
    LOOKAHEAD(2) VarIdentifier()
}

void TypeBound():
{}
{
    <Lt> TypeElement() (<And> TypeElement())*
}

void ModuleDeclaration():
{}
{
    <Module> TypeIdentifier() 
    ModuleBody()
}

void ModuleBody():
{}
{
    (LOOKAHEAD(TypeDeclaration()) TypeDeclaration() | LOOKAHEAD(VariableOrFunctionDeclaration()) VariableOrFunctionDeclaration()) 
    (LOOKAHEAD( (TypeDeclaration() | VariableOrFunctionDeclaration()))  (LOOKAHEAD(TypeDeclaration()) TypeDeclaration() |LOOKAHEAD(VariableOrFunctionDeclaration()) VariableOrFunctionDeclaration()))*
}

void Literal() #void:
{}
{
     FunctionLiteral() |
     BoolLiteral() |
     IntLiteral() |
     FloatLiteral() |
     StringLiteral() |
     TupleLiteral() |
     ListLiteral() |
     UndefinedLiteral()
}

ASTCompileUnit CompileUnit():
{}
{
    ( LOOKAHEAD(Assignment()) Assignment() | LOOKAHEAD(MethodInvocation()) MethodInvocation() | Statement() | SP())* <EOF> {
        return jjtThis;
    }
}

void Statement() #void:
{}
{
    LOOKAHEAD(Declaration()) Declaration() |
    ImportStatement() |
    LOOKAHEAD(ModifierStatement()) ModifierStatement() |
    LOOKAHEAD(Documentation()) Documentation() | 
    LOOKAHEAD(ExtendsType()) ExtendsType()
}

void Declaration() #void:
{}
{
    LOOKAHEAD(VariableOrFunctionDeclaration()) VariableOrFunctionDeclaration() |
    LOOKAHEAD(TypeDeclaration()) TypeDeclaration() |
    LOOKAHEAD(FuncAliasDeclaration()) FuncAliasDeclaration() | 
    LOOKAHEAD(AlgebraicDataTypeDecl()) AlgebraicDataTypeDecl() | 
    LOOKAHEAD(InterfaceDeclaration()) InterfaceDeclaration() |
    LOOKAHEAD(TypeAliasDeclaration()) TypeAliasDeclaration() |
    LOOKAHEAD(ModuleDeclaration()) ModuleDeclaration() |
    LOOKAHEAD(EnumDeclaration()) EnumDeclaration()
}

void MethodInvocation():
{}
{
    LOOKAHEAD(2) ElementAccess() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())? | 
    LOOKAHEAD(2) MethodName() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())? |
    LOOKAHEAD(TypeIdentifier() <Dot> MethodName() Arguments()) TypeIdentifier() <Dot> MethodName() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())?| 
    LOOKAHEAD(ExpressionName() MethodName() Arguments()) ExpressionName() MethodName() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())?| 
    LOOKAHEAD((<LeftParen>)? Literal() (<RightParen>)? <Dot> MethodName() Arguments()) (LOOKAHEAD(<LeftParen>) <LeftParen>)? Literal() (<RightParen>)? <Dot> MethodName() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())?|
    LOOKAHEAD(FunctionLiteral() Arguments()) FunctionLiteral() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())? |
    LOOKAHEAD(<LeftParen> Expression() <RightParen>) <LeftParen> Expression() <RightParen> <Dot> MethodName() Arguments() (LOOKAHEAD(<Dot> MethodInvocation()) <Dot> MethodInvocation())?
}

void Arguments():
{}
{
    <LeftParen> (Argument() ((",")? Argument())*)? <RightParen>
}

void Argument():
{}
{
    Expression()
}

void Expression() #void:
{}
{
    LOOKAHEAD(Assignment()) Assignment() |
    SwitchExpr() |
    LOOKAHEAD(OrExpr()) OrExpr() 
}

void Assignment():
{}
{
    LeftHandSide() AssignmentOperator() Expression()
}

void LeftHandSide():
{}
{
    LOOKAHEAD(2) ElementAccess() |
    LOOKAHEAD(2) VarIdentifier()
}

void AssignmentOperator() #void:
{}
{
    Assign() | AA() | SA() | MA() | DA() | RA()
}

void SwitchExpr():
{}
{
    <Switch> Expression() (LOOKAHEAD(SwitchCase()) SwitchCase())+
}

void SwitchCase():
{}
{
    <Case> SwitchPattern()
}

void SwitchPattern() #void:
{}
{
    Expression() (ColonType())? <DoubleArrow> Expression()
}

void ColonType() #void:
{}
{
    <Colon> TypeElement()
}

void OrExpr()#void:
{}
{
    (AndExpr() (LOOKAHEAD(2) Or() AndExpr())*) #ExprNode(>1)
}

void AndExpr()#void:
{}
{
    (Equality() (LOOKAHEAD(2) And() Equality())*) #ExprNode(>1)
}

void Equality()#void:
{}
{
    (Relational() (LOOKAHEAD(2) (EqualTo() | NotEqualTo()) Relational())*) #ExprNode(>1)
}

void Relational()#void:
{}
{
    (Range() (LOOKAHEAD(2) (LessThan() | GreaterThan()| LessThanEqualTo() | GreaterThanEqualTo()) Range())*) #ExprNode(>1)
}

void Range()#void:
{}
{
    (Additive() (LOOKAHEAD(2) ( ClosedRange() | HalfOpenRange()) Additive())*) #ExprNode(>1)
}

void Additive() #void:
{}
{
    (Multiplicative() (LOOKAHEAD(2) (Plus() | Minus()) Multiplicative())* ) #ExprNode(>1)
}

void Multiplicative() #void:
{}
{
    UnaryExpr() (LOOKAHEAD(2) (Star() | Slash() | SafeDiv() | SafeRem() | Percent() | Hat()) UnaryExpr())*  #ExprNode(>1)
}

void UnaryExpr() #void:
{}
{
   (UnaryPlus() UnaryExpr() |
    UnaryMinus() UnaryExpr() |
    UnaryExprNotPlusMinus() ) #ExprNode(>1)
}

void UnaryExprNotPlusMinus() #void:
{}
{
    UnaryBang() UnaryExpr() #ExprNode(>1)|
    LOOKAHEAD(CastExpression()) CastExpression() #ExprNode(>1)| 
    LOOKAHEAD(PostFixExpression()) PostFixExpression() #ExprNode(>1)
}

void CastExpression():
{}
{
    <LeftParen> UnaryExpr() <RightParen> <CastArrow> TypeElement()
}

void PostFixExpression() #void:
{}
{
    LOOKAHEAD(Primary()) Primary() #ExprNode(>1) |
    LOOKAHEAD(ExpressionName()) ExpressionName() #ExprNode(>1)
}

void ExpressionName():
{}
{
    (LOOKAHEAD(ElementAccess() <Dot>) ElementAccess() <Dot>)? Identifier() 
}

void Primary() #void:
{}
{
    LOOKAHEAD(Literal())                              Literal() #ExprNode(>1)|
    LOOKAHEAD(NewInstance())                          NewInstance() #ExprNode(>1)|
    LOOKAHEAD(MethodInvocation())                     MethodInvocation() #ExprNode(>1)|
    LOOKAHEAD(ElementAccess())                        ElementAccess() #ExprNode(>1)|
    WildCard() #ExprNode(>1)|
    LOOKAHEAD(<LeftParen> Expression() <RightParen>)  <LeftParen> Expression() <RightParen> #ExprNode(>1)
}


void NewInstance():
{}
{
    TypeIdentifier() (LOOKAHEAD(Arguments()) Arguments())?
}

void ElementAccess():
{}
{
    (LOOKAHEAD(ModuleName() <DoubleColon>) ModuleName() <DoubleColon>)? Identifier() (LOOKAHEAD(<Dot> Identifier()) <Dot> Identifier())+
}

void Documentation():
{}
{
    <BeginDoc> StringLiteral() <EndDoc> 
}

void ModifierStatement():
{}
{
     "#" (AllModifier())+
}

void AllModifier() #void:
{}
{
    AbstractModifier() |
    OverrideModifier() |
    PrivateModifier() | 
    PublicModifier() |
    SealedModifier() | 
    LazyModifier() | 
    VariableModifier()
}

TOKEN:
{
    < LeftBracket : "[" > |
    < RightBracket : "]" > |
    < LeftBrace : "{" > |
    < RightBrace : "}" > |
    < LeftParen : "(" > |
    < RightParen : ")" > |
    < Colon : ":" > |
    < SemiColon : ";" > | 
    < DoubleColon : "::"> |
    < Dot : "." > |
    < SP : "\n\n" | "\r\r" | "\r\n\r\n" >
}

TOKEN:
{

    < EqualSign : "=" >|
    < AA : "+=" >|
    < SA : "-=" >|
    < MA : "*=" >|
    < DA : "/=" >|
    < RA : "%=" >|
    < Lt : "<" >|
    < LtE : "<=" >|
    < Gt : ">" >|
    < GtE : ">=" >|
    < Plus : "+" >|
    < Minus : "-" >|
    < Star : "*" >|
    < Slash : "/" >|
    < SafeDiv : "/?" >|
    < Percent : "%" >|
    < SafeRem : "%?" >|
    < Tilde : "~" >|
    < Bang : "!" >|
    < And : "&" > |
    < Or : "|" >|
    < Hat : "^" >|
    < Question : "?" >|
    < ReverseArrow : "<-" >|
    < SingleArrow : "->" >|
    < CastArrow : "~>" >|
    < TypeCheckArrow : "~>?" >|
    < DoubleArrow : "=>" >|
    < EqualTo : "==" >|
    < NotEqualTo : "!=" >|
    < NonComparable : "!<>=" >|
    < Comparable : "<>=" >|
    < ClosedRange : ".." >|
    < HalfOpenRange : ".<" >

}

TOKEN:
{
    < BeginDoc : "{:" > |
    < EndDoc : ":}" > |
    < Atmark : "@" >
}

SPECIAL_TOKEN:
{

    < NewLine : "\r"
              | "\n" 
              | "\r\n" > 
}

void Identifier() #void:
{}
{
    TypeIdentifier() |
    VarIdentifier() 
}

void ModuleName():
{}
{
    TypeIdentifier()
}

void MethodName():
{}
{
    VarIdentifier()
}

void ExprName():
{}
{
    VarIdentifier()
}

void ReturnType():
{}
{
    TypeElement()
}

void SuperType():
{}
{
    TypeElement()
}

void Interfaces():
{}
{
    (LOOKAHEAD(2) TypeElement())+
}

Token TypeIdentifier():
{
    Token t;
}
{
    t = <TypeIdentifier> {
        jjtThis.jjtSetValue(t);
        return t;
    }
}

Token VarIdentifier():
{
    Token t;
}
{
    t = <VarIdentifier> {
        jjtThis.jjtSetValue(t);
        return t;
    } |
    t = WildCard() {
        return t;
    }
}

Token WildCard():
{
    Token t;
}
{
    t = <WildCard> {
        jjtThis.jjtSetValue(t);
        return t;
    }
}

void Annotation():
{}
{
    <Atmark> TypeIdentifier()
}

SKIP:
{
    " " |
    "\t" |
    < "//" (~["\r","\n"])* > |
    "/*" {
        commentNestLevel++;
        SwitchTo(InComment);
    } |
    < "__" <NewLine> >
}

<InComment> SKIP:
{
    "/*" {
        commentNestLevel++;
    } |
    < ~[]> |
    <EndOfLine : "\n" | "\r" | "\r\n" > |
    "*/" { 
        commentNestLevel--;
        if(commentNestLevel == 0){
            SwitchTo(DEFAULT);
        }
    }
}

TOKEN:
{
    < Abstract : "abstract" > |
    < Case : "case" > | 
    < Check : "check" > |
    < Enum : "enum" > |
    < FuncAlias : "funcalias" > |
    < Import : "import" > |
    < Interface : "interface" > |
    < Lazy : "lazy" > |
    < Module : "module" >|
    < Override : "override" >|
    < Private : "private" >|
    < Public : "public" >|
    < Sealed : "sealed" >|
    < Switch : "switch" >|
    < Type : "type" >|
    < TypeAlias : "typealias" >|
    < Undefined : "undefined" >|
    < Variable : "var" >
}

TOKEN:
{
    < BoolLiteral : "true"
                  | "false" > |
    < IntLiteral : <Zero> | <NonZero> (<Zero> | <NonZero>)* > |
    < Hexadecimal : "0" ["x","X"] (<HexDigit>)+ > |
    < #HexDigit : ["0"-"9" , "A"-"F" , "a"-"f"] > |
    < FloatLiteral : (<Zero> | <IntLiteral>) <Dot> (<Zero> | <NonZero>)+ (<Exp> (<Minus>)? <IntLiteral> )? > |
    < #Zero : "0" > |
    < #NonZero : ["1"-"9"] > |
    < #Exp : "e" | "E" > |
    < StringLiteral : "\"" (<StringCharacter>)* "\"" > |
    < #StringCharacter : (~["\"","\\","\n","\r"]) 
                       | <StringEscapeSeq> 
                       | <UnicodeEscape> > |
    < StringEscapeSeq : "\\" ["b","t","n","f","r","\"","\\","\'"] > |
    < UnicodeEscape : "\\u" <HexDigit> <HexDigit> <HexDigit> <HexDigit> >
}

TOKEN:
{
    < TypeIdentifier : ["A"-"Z"] (["A"-"Z","a"-"z","_","0"-"9","'"])* > | 
    < VarIdentifier : ["a"-"z"] (["A"-"Z","a"-"z","_","0"-"9","'"])* > |
    < WildCard : "_" >
}

void AbstractModifier():
{
    Token t;
}
{
    t = <Abstract> {
        jjtThis.jjtSetValue(t);
    }
}

void OverrideModifier():
{
    Token t;    
}
{
    t = <Override> {
        jjtThis.jjtSetValue(t);
    }
}

void PrivateModifier():
{
    Token t;
}
{
    t = <Private> {
        jjtThis.jjtSetValue(t);
    }
}

void PublicModifier():
{
    Token t;
}
{
    t = <Public> {
        jjtThis.jjtSetValue(t);
    }
}

void SealedModifier():
{
    Token t;
}
{
    t = <Sealed> {
        jjtThis.jjtSetValue(t);
    }
}

void LazyModifier():
{
    Token t;
}
{
    t = <Lazy> {
        jjtThis.jjtSetValue(t);
    }
}

void VariableModifier():
{
    Token t;
}
{
    t = <Variable> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryPlus():
{
    Token t;
}
{
    t = <Plus> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryBang():
{
    Token t;
}
{
    t = <Bang> {
        jjtThis.jjtSetValue(t);
    }
}

void UnaryMinus():
{
    Token t;
}
{
    t = <Minus> {
        jjtThis.jjtSetValue(t);
    }
}

void Star():
{
    Token t;
}
{
    t = <Star> {
        jjtThis.jjtSetValue(t);
    }
}

void Slash():
{
    Token t;
}
{
    t = <Slash> {
        jjtThis.jjtSetValue(t);
    }
}

void Percent():
{
    Token t;
}
{
    t = <Percent> {
        jjtThis.jjtSetValue(t);
    }
}

void SafeDiv():
{
    Token t;
}
{
    t = <SafeDiv> {
        jjtThis.jjtSetValue(t);
    }
}

void SafeRem():
{
    Token t;
}
{
    t = <SafeRem> {
        jjtThis.jjtSetValue(t);
    }
}

void Hat():
{
    Token t;
}
{
    t = <Hat> {
        jjtThis.jjtSetValue(t);
    }
}

void Plus():
{
    Token t;
}
{
    t = <Plus> {
        jjtThis.jjtSetValue(t);
    }
}

void Minus():
{
    Token t;
}
{
    t = <Minus> {
        jjtThis.jjtSetValue(t);
    }
}

void EqualTo():
{
    Token t;
}
{
    t = <EqualTo> {
        jjtThis.jjtSetValue(t);
    }
}

void NotEqualTo():
{
    Token t;
}
{
    t = <NotEqualTo> {
        jjtThis.jjtSetValue(t);
    }
}

void GreaterThan():
{
    Token t;
}
{
    t = <Gt> {
        jjtThis.jjtSetValue(t);
    }
}

void LessThan():
{
    Token t;
}
{
    t = <Lt> {
        jjtThis.jjtSetValue(t);
    }
}

void GreaterThanEqualTo():
{
    Token t;
}
{
    t = <GtE> {
        jjtThis.jjtSetValue(t);
    }
}

void LessThanEqualTo():
{
    Token t;
}
{
    t = <LtE> {
        jjtThis.jjtSetValue(t);
    }
}

void Comparable():
{
    Token t;
}
{
    t = <Comparable> {
        jjtThis.jjtSetValue(t);
    }
}

void NonComparable():
{
    Token t;
}
{
    t = <NonComparable> {
        jjtThis.jjtSetValue(t);
    }
}

void And():
{
    Token t;
}
{
    t = <And> {
        jjtThis.jjtSetValue(t);
    }
}
void Or():
{
    Token t;
}
{
    t = <Or> {
        jjtThis.jjtSetValue(t);
    }
}


void BoolLiteral():
{
    Token t;
}
{
    t = <BoolLiteral> {
        jjtThis.jjtSetValue(t);
    }
}


void IntLiteral():
{
    Token t;
}
{
    t = <IntLiteral> {
        jjtThis.jjtSetValue(t);
    }| 
    t = <Hexadecimal> {
        jjtThis.jjtSetValue(t);
    }
}

void FloatLiteral():
{
    Token t;
}
{
    t = <FloatLiteral> {
        jjtThis.jjtSetValue(t);
    }
}

void StringLiteral():
{
    Token t;
}
{
    t = <StringLiteral> {
        jjtThis.jjtSetValue(t);
    }
}

void ListLiteral():
{}
{
    <LeftBracket> (ListBody())* <RightBracket>
}

void ListBody() #void:
{}
{
    LOOKAHEAD(2) Literal() |
    LOOKAHEAD(2) WildCard()
}

void TupleLiteral():
{
    Token t;
}
{
    t = "#(" (Expression() ((",")? Expression())*)? <RightParen>
}

void UndefinedLiteral():
{
    Token t;
}
{
    t = <Undefined> {
        jjtThis.jjtSetValue(t);
    }
}

void SingleArrow():
{
    Token t;
}
{
    t = <SingleArrow> {
        jjtThis.jjtSetValue(t);
    }
}
void Assign():
{
    Token t;
}
{
    t = <EqualSign> {
        jjtThis.jjtSetValue(t);
    }
}

void ClosedRange():
{
    Token t;
}
{
    t = <ClosedRange> {
        jjtThis.jjtSetValue(t);
    }
}

void HalfOpenRange():
{
    Token t;
}
{
    t = <HalfOpenRange> {
        jjtThis.jjtSetValue(t);
    }
}

void AA():
{
    Token t;
}
{
    t = <AA> {
        jjtThis.jjtSetValue(t);
    }
}

void SA():
{
    Token t;
}
{
    t = <SA> {
        jjtThis.jjtSetValue(t);
    }
}

void MA():
{
    Token t;
}
{
    t = <MA> {
        jjtThis.jjtSetValue(t);
    }
}

void DA():
{
    Token t;
}
{
    t = <DA> {
        jjtThis.jjtSetValue(t);
    }
}

void RA():
{
    Token t;
}
{
    t = <RA> {
        jjtThis.jjtSetValue(t);
    }
}

void SP():
{
    Token t;
}
{
    t = <SP> {
        t.image = "";
        jjtThis.jjtSetValue(t);
    }
}
