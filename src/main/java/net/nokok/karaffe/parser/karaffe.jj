/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. karaffe.jj */
/*@egen*///Karaffe Javacc file

options {
    STATIC = false;
    IGNORE_CASE = false;
    UNICODE_INPUT = true;
                 
                   
                                                                                 
}

PARSER_BEGIN(KaraffeParser)
package net.nokok.karaffe.parser;

public class KaraffeParser/*@bgen(jjtree)*/implements KaraffeParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTKaraffeParserState jjtree = new JJTKaraffeParserState();

/*@egen*/

    public KaraffeParser(String sourceCode){
        this(new java.io.StringReader(sourceCode));
    }

    public int getCurrentTokenBeginColumn(){
        return jj_input_stream.getBeginColumn();
    }

    public int getCurrentTokenEndColumn(){
        return jj_input_stream.getEndColumn();
    }

    public int getCurrentLine(){
        return jj_input_stream.getEndLine();
    }
}


PARSER_END(KaraffeParser)

TOKEN_MGR_DECLS:
{
    public static int commentNestLevel = 0;
}

/*
\u30b3\u30e1\u30f3\u30c8\u306e\u51e6\u7406
*/
SKIP:
{
    " "
    | "\t"
    | < "//" (~["\n"])* <NewLine> >
    | "/*" {
        commentNestLevel++;
        SwitchTo(InComment);
    }
}

<InComment> SKIP:
{
    "/*" {
        commentNestLevel++;
    }
    | <EndOfLine : <NewLine>> 
    | "*/" {
        commentNestLevel--;
        if(commentNestLevel == 0){
            SwitchTo(DEFAULT);
        }
    }
}

/**
    Reserved keywords 
*/
TOKEN:
{
      < Check : "check" >
    | < Interface : "interface" >
    | < Public : "public" >
    | < SideEffect : "seffect" >
    | < Switch : "switch" >
    | < To : "to" >
    | < Type : "type" >
    | < Undefined : "undefined" >
}

/**
    Literals
*/
TOKEN:
{
      < BoolLiteral : "true"
                    | "false" >
    | < IntLiteral : <Zero> | (<Minus>)? <NonZero> (<Zero> | <NonZero>)* >
    | < Hexadecimal : (<Minus>)? "0" ["x","X"] (<HexDigit>)+ >
    | < #HexDigit : ["0"-"9" , "A"-"F" , "a"-"f"] > 
    | < FloatLiteral : (<Minus>)? (<Zero> | <IntLiteral>) <Dot> (<Zero> | <NonZero>)+ (<Exp> <IntLiteral> )? >
    | < #Minus : "-" >
    | < #Zero : "0" >
    | < #NonZero : ["1"-"9"] >
    | < #Exp : "e" | "E" >
    | < StringLiteral : "\"" (<StringCharacter>)* "\"" >
    | < #StringCharacter : (~["\"","\\","\n","\r"]) 
                         | <StringEscapeSeq> 
                         | <UnicodeEscape> >
    | < StringEscapeSeq : "\\" ["b","t","n","f","r","\"","\\","\'"] >
    | < UnicodeEscape : "\\u" <HexDigit> <HexDigit> <HexDigit> <HexDigit> >
}

/**
    Identifiers
*/
TOKEN:
{
      < Identifier : <IdentifierHead> (<IdentifierHead> | <IdentifierCharacter>)* ("[" "]")?>
    | < #IdentifierHead :      [
                                    "A"-"Z", //A-Z
                                    "a"-"z", //a-z
                                    "\u3040"-"\u309f", //\u3072\u3089\u304c\u306a Hiragana
                                    "\u30a0"-"\u30ff", //\u30ab\u30bf\u30ab\u30ca Katakana
                                    "\u4e00"-"\u9fff"  //\u6f22\u5b57     CJK Unified Ideographs
                               ]  >
    | < #IdentifierCharacter : [
                                    "0"-"9", //0-9
                                    "A"-"Z", //A-Z
                                    "a"-"z", //a-z
                                    "_",          //_
                                    "\u3040"-"\u309f", //\u3072\u3089\u304c\u306a Hiragana
                                    "\u30a0"-"\u30ff", //\u30ab\u30bf\u30ab\u30ca Katakana
                                    "\u4e00"-"\u9fff"  //\u6f22\u5b57     CJK Unified Ideographs
                               ] >
    | < TypeParameter : ["A"-"Z"] > //A-Z
}

/**
    Separators
*/
TOKEN:
{
      < LeftBracket : "[" >
    | < RightBracket : "]" >
    | < Colon : ":" >
    | < EqualSign : "=" >
    | < Dot : "." >
}

/**
    Other tokens
*/
TOKEN:
{
      < NewLine : "\r"
                | "\n" 
                | "\r\n" >
}

/**
 * CompileUnit = Declaration
 */
public ASTCompileUnit CompileUnit():
{/*@bgen(jjtree) CompileUnit */
  ASTCompileUnit jjtn000 = new ASTCompileUnit(JJTCOMPILEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) CompileUnit */
    try {
/*@egen*/
    (Statement())* <EOF>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//Statement

/**
    Statement = Declaration
 */
void Statement():
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    Declaration()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


// Declaration

/**
 Declaration = TypeDcl
             | TypeAliasDcl
             | InheritanceDcl
             | InterfaceDcl
             | TopLevelFunctionDcl
             | TopLevelVariableDcl
 */
void Declaration():
{/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
     try {
/*@egen*/
     LOOKAHEAD(3) TypeDcl()
     | TypeAliasDcl()/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

/**
    NestDeclaration = "." Declaration
 */
void NestDeclaration():
{/*@bgen(jjtree) NestDeclaration */
  ASTNestDeclaration jjtn000 = new ASTNestDeclaration(JJTNESTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NestDeclaration */
    try {
/*@egen*/
    <Dot> Declaration() NewLine()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
    TypeDcl = "type" NewTypeName TypeParameters? NewLine NestDeclaration
    TypeParameters = "[" TypeParameter1 TypeParameter2 ... "]"

    e.g.
    type Foo 
    . dcl

    type Bar[A]
    . dcl

    type Baz[A B C]
    . dcl
 */
void TypeDcl():
{/*@bgen(jjtree) TypeDcl */
  ASTTypeDcl jjtn000 = new ASTTypeDcl(JJTTYPEDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeDcl */
    try {
/*@egen*/
    <Type> Identifier() (TypeParameters())? NewLine() (NestDeclaration())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
    TypeAliasDcl = "type" NewTypeName TypeParameters? "=" ExistingTypeName TypeParameters? NewLine NestDeclaration

    e.g.
    type Foo = Any
    . dcl

    type Foo[A] = Any
    . dcl

    type Foo = Bar[A]
    . dcl

    type Foo[A] = Bar[A]
    . dcl
 */
void TypeAliasDcl():
{/*@bgen(jjtree) TypeAliasDcl */
  ASTTypeAliasDcl jjtn000 = new ASTTypeAliasDcl(JJTTYPEALIASDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeAliasDcl */
    try {
/*@egen*/
    <Type> Identifier() (TypeParameters())? EqualOperator() Identifier() (TypeParameters())? NewLine() (NestDeclaration())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
    InterfaceDcl = "interface" InterfaceName TypeParameters? NewLine NestDeclaration

    e.g.
    interface Foo
    . dcl

    interface Foo[A]
    . dcl
 */
void InterfaceDcl():
{/*@bgen(jjtree) InterfaceDcl */
  ASTInterfaceDcl jjtn000 = new ASTInterfaceDcl(JJTINTERFACEDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InterfaceDcl */
    try {
/*@egen*/
    <Interface> Identifier() NewLine()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
    TopLevelFunctionDcl = TopLevelExplicitTypeFunctionDcl
                        | TopLevelFunctionLiteralDcl
 */

/**
    TopLevelExplicitTypeFunctionDcl = Identifier ":" Identifiers "to" Identifier Expression

    e.g.
    bar : TypeName to TypeName =
 */
void TopLevelExplicitTypeFunctionDcl():
{/*@bgen(jjtree) TopLevelExplicitTypeFunctionDcl */
  ASTTopLevelExplicitTypeFunctionDcl jjtn000 = new ASTTopLevelExplicitTypeFunctionDcl(JJTTOPLEVELEXPLICITTYPEFUNCTIONDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TopLevelExplicitTypeFunctionDcl */
    try {
/*@egen*/
    Identifier() ":" Identifier() <To> Identifier() EqualOperator() Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
    TypeParameters = "[" TypeParameter1 TypeParameter2 ... "]"
 */
void TypeParameters():
{/*@bgen(jjtree) TypeParameters */
  ASTTypeParameters jjtn000 = new ASTTypeParameters(JJTTYPEPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeParameters */
    try {
/*@egen*/
    "[" (TypeParameter())+ "]"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//Expressions

/**
    Expression = Literal
 */
void Expression():
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    Literal()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Literal():
{/*@bgen(jjtree) Literal */
    ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Literal */
      try {
/*@egen*/
      t = <BoolLiteral>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }
    | t = <IntLiteral>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }
    | t = <FloatLiteral>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }
    | t = <StringLiteral>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }/*@bgen(jjtree)*/
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}

//Identifiers

/**
    Identifier = IdentifierHead IdentifierCharacter
 */
void Identifier():
{/*@bgen(jjtree) Identifier */
    ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t = <Identifier>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TypeParameter():
{/*@bgen(jjtree) TypeParameter */
    ASTTypeParameter jjtn000 = new ASTTypeParameter(JJTTYPEPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) TypeParameter */
    try {
/*@egen*/
    t = <TypeParameter>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {
        jjtn000.jjtSetValue(t);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EqualOperator():
{/*@bgen(jjtree) EqualOperator */
  ASTEqualOperator jjtn000 = new ASTEqualOperator(JJTEQUALOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualOperator */
    try {
/*@egen*/
    <EqualSign>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NewLine():
{/*@bgen(jjtree) NewLine */
  ASTNewLine jjtn000 = new ASTNewLine(JJTNEWLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NewLine */
    try {
/*@egen*/
    <NewLine>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}